
/*
 * Copyright (c) 2010 Novell, Inc.
 * All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail,
 * you may find current contact information at www.novell.com
 */

/**
 * File:        include/scanner/dialogs.ycp
 * Package:     Configuration of scanner
 * Summary:     Dialogs definitions
 * Authors:     Johannes Meixner <jsmeix@suse.de>
 *
 * $Id$
 * $Id$
 */

{

textdomain "scanner";

import "Label";
import "Popup";
import "Wizard";
import "Arch";
import "Scanner";
import "WizardHW";
import "Confirm";

include "scanner/helps.ycp";

/**
 * Ask for user confirmation if necessary before aborting.
 * At present full transaction semantics (with roll-back) is not implemented.
 * What is implemented is that it does not leave the system in an inconsistent state.
 * It does one setup completely or not at all (i.e. all or nothing semantics regarding one setup.)
 * "One setup" means the smallest amount of setup actions
 * which lead from one consistent state to another consistent state.
 * "Consistent state" is meant from the user's point of view
 * (i.e. set up one SANE backend completely or set up the saned completely)
 * and not from a low-level (e.g. filesystem or kernel) point of view.
 * If the user does malicious stuff (e.g. killing YaST)
 * or if the user ignores warning messages then it is possible (and it is accepted)
 * that the user can force to set up even an inconsistent state
 * (e.g. activate a backend but don't activate a required service).
 * At present all what is needed for one setup is committed to the system instantly.
 * For example:
 * Install additional packages (like hp-officeJet),
 * then set up and start special required services (like ptal),
 * then activate the backend in /etc/sane/dll.conf
 * finally determine which scanners have become actually active
 * (see the ActivateBackend and DeactivateBackend functions).
 * It is necessary to commit instantly to be able to test a scanner
 * and to show a true feedback to the user which scanners are actually active.
 * @return true if nothing was committed or if user confirms to abort
 */
boolean ReallyAbort()
{ // As roll-back is not implemented 'Popup::ReallyAbort(true)' doesn't make sense.
  // Scanner::Modified() returns true if something was committed to the system.
  return !Scanner::Modified() || Popup::ReallyAbort(false);
}

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog()
{ // Confirm::MustBeRoot() returns 'true' when the current user is root.
  // Otherwise the user is asked for confirmation whether he want's to continue
  // despite the fact that the module might not work correctly
  if( ! Confirm::MustBeRoot() ) return `abort;
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // the "abort" button in a single configuration dialog must now be named "cancel":
  Wizard::SetAbortButton( `abort, Label::CancelButton() );
  // No "back" or "next" button at all makes any sense here
  // because there is no dialog where to go "back"
  // and the "next" dialog (i.e. the Overview dialog) is launced automatically
  Wizard::HideBackButton();
  Wizard::HideNextButton();
  Wizard::RestoreHelp( HELPS["read"]:"" );
  boolean ret = Scanner::Read();
  return ret ? `next : `abort;
}

/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol WriteDialog()
{ // No "abort" or "back" or "next" button at all makes any sense here:
  Wizard::HideAbortButton();
  Wizard::HideBackButton();
  Wizard::HideNextButton();
  Wizard::RestoreHelp(HELPS["write"]:"");
  boolean ret = Scanner::Write();
  return ret ? `next : `abort;
}

/**
 * Overview dialog
 * does what the two dialogs SummaryDialog() and OverviewDialog() did before:
 * A dialog showing the detected scanners and allowing to configure them.
 * @return any The value of the resulting UserInput.
 */
any OverviewDialog()
{ // Caption of the OverviewDialog
  // (the same as the caption of the matching help text)
  string caption = _("Scanner Configuration");
  WizardHW::CreateHWDialog( caption,
                            HELPS["overview"]:"",
                            [ // Header for a column of the overview table
                              // where scanners and associated drivers are listed:
                              _("Driver"),
                              // Header for a column of the overview table
                              // where scanners and associated drivers are listed:
                              _("Scanner")
                            ],
                            [ [ `restart_detection,
                                // Label of a button to restart autodetection of scanners:
                                _("&Restart Detection")
                              ],
                              [ `test,
                                // Label of a button to test a scanner:
                                _("&Test")
                              ],
                              [ `run_hpsetup,
                                // Label of a button to run hp-setup.
                                // Do not change or translate "hp-setup", it is a program name:
                                _("Run &hp-setup")
                              ],
                              [ `network_scanning,
                                // Label of a button to go to the network scanning dialog.
                                // Do not confuse "scanning via network"
                                // (i.e. use a remote scanner via another host in the network)
                                // with "scanning the network"
                                // (i.e. scan the network for other hosts or services):
                                _("Scanning via &Network...")
                              ]
                            ]
                          );
  WizardHW::SetContents( Scanner::OverviewContents() );
  // In the Overview dialog the "next" button is used to finish the whole module.
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // the "finish" button in an Overview dialog must now be named "OK":
  Wizard::SetNextButton( `next, Label::OKButton() );
  // In the Overview dialog it does not make sense to have a button with "back" functionality
  // which is named "Cancel" according to the new YaST style guide at
  // http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // because there is nothing to "cancel" in the Overview dialog because it
  // only shows information about the current state of the configuration
  // but the Overview dialog itself does not do any change of the configuration.
  // The Overview dialog has actually the same meaning for the user
  // as a plain notification popup which has only a "OK" button.
  // If the user does not agree to what is shown in the Overview dialog
  // he must launch a configuration sub-dialog to change the configuration.
  // If the user accepted in such a configuration sub-dialog what he changed
  // via the "OK" button there, the change is applied and the Overview dialog
  // shows the new current state of the configuration, see
  // http://en.opensuse.org/YaST/Development/Printer_Enhancement#Basic_Implementation_Principles:
  // so that it is not possible to "cancel" the change in the Overview dialog.
  // Any change of the configuration is done in sub-dialogs which are called
  // from the Overview dialog (even the "Confirm Deletion" popup is such a sub-dialog)
  // and in all those sub-dialogs there is a button with "cancel" functionality.
  Wizard::HideBackButton();
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // there is no longer a "abort" functionality which exits the whole module.
  // Instead this button is now named "Cancel" and its functionality is
  // to go back to the Overview dialog (i.e. what the "back" button would do)
  // because it reads "Cancel - Closes the window and returns to the overview."
  // In this case this does not make sense because this is already the "overview".
  // Therefore the button with the "abort" functionality is not shown at all:
  Wizard::HideAbortButton();
  any ret = nil;
  while(true)
  { // UI::UserInput returns the label of the button which was cklicked:
    ret = UI::UserInput();
    /* back or abort */
    if( ret == `abort
        || ret == `cancel
      )
    { if( ! ReallyAbort() ) continue;
      break;
    }
    /* next or back */
    if( ret == `next
        || ret == `back
      )
    { break;
    }
    /* add */
    if( ret == `add )
    { // Unselect a previously selected autodetected scanner
      // to have it no longer preselected in the select model dialog:
      Scanner::selected_autodetected_scanners_index = -1;
      // Unselect a previously selected model in the database
      // to have it no longer preselected in the select model dialog:
      Scanner::selected_model_database_index = -1;
      // Exit this dialog and run the AddSequence() via the sequencer in wizards.ycp:
      break;
    }
    /* edit */
    if( ret == `edit )
    { // Get what was selected:
      string selected_item_id = WizardHW::SelectedItem();
      y2milestone( "selected_item_id in OverviewDialog: %1", selected_item_id );
      if( selected_item_id == "" )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when nothing was selected:
                           _("Nothing Selected"),
                           // Body of a Popup::AnyMessage when nothing was selected:
                           _("Select an entry.")
                         );
        continue;
      }
      // The selected_item_id can be one of the following (see the OverviewContents function):
      // "autodetected_scanner:[0-9]*" where [0-9]* is the autodetected_scanners_index
      // (i.e. the index in the autodetected_scanners list to which the selected item matches)
      // "active_scanner:[0-9]*" where [0-9]* is the active_scanners_index
      // (i.e. the index in the active_scanners list to which the selected item matches)
      // "active_backend:[0-9]*" where [0-9]* is the active_backends_index
      // (i.e. the index in the active_backends list to which the selected item matches)
      // "nothing" which is used as fallback only if none of the above was set
      // (i.e. if neither a scanner was autodetected nor an active scanner nor an active backend exists)
      if( issubstring( selected_item_id, "autodetected_scanner:" ) )
      { // Configure a selected autodetected scanner:
        Scanner::selected_autodetected_scanners_index = tointeger( filterchars( selected_item_id, "0123456789" ) );
        y2milestone( "Selected autodetected scanners index in OverviewDialog is: %1", Scanner::selected_autodetected_scanners_index );
        if( Scanner::selected_autodetected_scanners_index < 0 )
        { ret = `add;
        }
        else
        { // Unselect a previously selected model in the database
          // to have it no longer preselected in the select model dialog
          // when the user has selected a not yet configured autodetected scanner:
          Scanner::selected_model_database_index = -1;
          ret = `configure;
        }
        // Exit this dialog and run the AddSequence() via the sequencer in wizards.ycp:
        break;
      }
      if( issubstring( selected_item_id, "active_scanner:" ) )
      { // Edit a selected active scanner:
        // Unselect a previously selected autodetected scanner
        // to have it no longer preselected in the select model dialog
        // but keep a possibly previously selected model in the database
        // because this model was normally added, configured, or edited before
        // (in particular if there is only one scanner connected):
        Scanner::selected_autodetected_scanners_index = -1;
        // Test if the active scanner is a remote scanner
        // (i.e. when it is accessed via the 'net' meta-backend):
        integer active_scanners_index = tointeger( filterchars( selected_item_id, "0123456789" ) );
        if( "net" == Scanner::active_scanners[active_scanners_index,"backend"]:"" )
        { // Exit this dialog and run the ConfigureNetworkScanningDialog via the sequencer in wizards.ycp:
          ret = `network_scanning;
          break;
        }
        // Exit this dialog and run the AddSequence() via the sequencer in wizards.ycp:
        ret = `edit;
        break;
      }
      if( issubstring( selected_item_id, "active_backend:" ) )
      { integer active_backends_index = tointeger( filterchars( selected_item_id, "0123456789" ) );
        // Test if the active backend is the 'net' meta-backend:
        if( "net" == Scanner::active_backends[active_backends_index]:"" )
        { // Exit this dialog and run the ConfigureNetworkScanningDialog via the sequencer in wizards.ycp:
          ret = `network_scanning;
          break;
        }
        // A selected active backend (without a matching active scanner) cannot be edited.
        // A selected active backend (without a matching active scanner) can only be deleted.
        Popup::AnyMessage( // Header of a Popup::AnyMessage when an active driver
                           // without a matching active scanner was selected
                           // and then the user clicked the [Edit] button.
                           // Translate 'Edit' to the exact label of the [Edit] button.
                           _("Edit Not Possible"),
                           // Body of a Popup::AnyMessage when an active driver
                           // without a matching active scanner was selected
                           // and then the user clicked the [Edit] button:
                           // Translate 'delete' to the exact label of the [Delete] button.
                           _("It is only possible to delete a driver without a matching scanner.")
                         );
        continue;
      }
      if( "nothing" == selected_item_id )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when there is only the fallback entry
                           // when there is neither a detected scanner nor an active scanner or driver
                           // and then the user clicked the [Edit] button.
                           // Translate 'Edit' to the exact label of the [Edit] button.
                           _("Edit Not Possible"),
                           // Body of a Popup::AnyMessage when there is only the fallback entry
                           // when there is neither a detected scanner nor an active scanner or driver
                           // and then the user clicked the [Edit] button.
                           // Translate 'add' to the exact label of the [Add] button.
                           _("It is only possible to add a scanner.")
                         );
        continue;
// Alternatively:
//        // Do the same as if the user had clicked the [Add] button:
//        // Unselect a previously selected autodetected scanner
//        // to have it no longer preselected in the select model dialog:
//        Scanner::selected_autodetected_scanners_index = -1;
//        // Unselect a previously selected model in the database
//        // to have it no longer preselected in the select model dialog:
//        Scanner::selected_model_database_index = -1;
//        // Exit this dialog and run the AddSequence() via the sequencer in wizards.ycp:
//        ret = `add;
//        break;
      }
      y2milestone( "selected_item_id is none of 'autodetected_scanner:...' 'active_scanner:...' 'active_backend:...' 'nothing'");
      continue;
    }
    /* delete */
    if( ret == `delete )
    { // Get what was selected:
      string selected_item_id = WizardHW::SelectedItem();
      y2milestone( "Selected item id in OverviewDialog: %1", selected_item_id );
      if( selected_item_id == "" )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when nothing was selected:
                           _("Nothing Selected"),
                           // Body of a Popup::AnyMessage when nothing was selected:
                           _("Select an entry.")
                         );
        continue;
      }
      // The selected_item_id can be one of the following (see the OverviewContents function):
      // "autodetected_scanner:[0-9]*" where [0-9]* is the autodetected_scanners_index
      // (i.e. the index in the autodetected_scanners list to which the selected item matches)
      // "active_scanner:[0-9]*" where [0-9]* is the active_scanners_index
      // (i.e. the index in the active_scanners list to which the selected item matches)
      // "active_backend:[0-9]*" where [0-9]* is the active_backends_index
      // (i.e. the index in the active_backends list to which the selected item matches)
      // "nothing" which is used as fallback only if none of the above was set
      // (i.e. if neither a scanner was autodetected nor an active scanner nor an active backend exists)
      if( issubstring( selected_item_id, "autodetected_scanner:" ) )
      { // A selected autodetected scanner (which is not yet configured) cannot be deleted.
        // A selected autodetected scanner can be edited.
        Popup::AnyMessage( // Header of a Popup::AnyMessage when an autodetected scanner
                           // which is not yet configured was selected
                           // and then the user clicked the [Delete] button.
                           // Translate 'Delete' to the exact label of the [Delete] button.
                           _("Delete Not Possible"),
                           // Body of a Popup::AnyMessage when an autodetected scanner
                           // which is not yet configured was selected
                           // and then the user clicked the [Delete] button:
                           // Translate 'edit' to the exact label of the [Edit] button.
                           _("It is only possible to edit a detected scanner.")
                         );
        continue;
      }
      if( "nothing" == selected_item_id )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when there is only the fallback entry
                           // when there is neither a detected scanner nor an active scanner or driver
                           // and then the user clicked the [Delete] button.
                           // Translate 'Delete' to the exact label of the [Delete] button.
                           _("Delete Not Possible"),
                           // Body of a Popup::AnyMessage when there is only the fallback entry
                           // when there is neither a detected scanner nor an active scanner or driver
                           // and then the user clicked the [Delete] button.
                           // Translate 'add' to the exact label of the [Add] button.
                           _("It is only possible to add a scanner.")
                         );
        continue;
      }
      // The selected_item_id is either "active_scanner:..." or "active_backend:...":
      string backend_name = "";
      if( issubstring( selected_item_id, "active_scanner:" ) )
      { // Delete a selected active scanner:
        integer active_scanners_index = tointeger( filterchars( selected_item_id, "0123456789" ) );
        backend_name = Scanner::active_scanners[active_scanners_index,"backend"]:"";
        // Test if the active scanner is a remote scanner
        // (i.e. when it is accessed via the 'net' meta-backend):
        if( "net" == backend_name )
        { // Exit this dialog and run the ConfigureNetworkScanningDialog via the sequencer in wizards.ycp:
          ret = `network_scanning;
          break;
        }
      }
      if( issubstring( selected_item_id, "active_backend:" ) )
      { // Delete a selected active backend (without a matching active scanner):
        integer active_backends_index = tointeger( filterchars( selected_item_id, "0123456789" ) );
        backend_name = Scanner::active_backends[active_backends_index]:"";
        // Test if the active backend is the 'net' meta-backend:
        if( "net" == backend_name )
        { // Exit this dialog and run the ConfigureNetworkScanningDialog via the sequencer in wizards.ycp:
          ret = `network_scanning;
          break;
        }
      }
      y2milestone( "Selected backend to be deleted (i.e. deactivated) is: %1", backend_name );
      if( "" == backend_name )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when nothing was selected:
                           _("Nothing Selected"),
                           // Body of a Popup::AnyMessage when nothing was selected:
                           _("Select an entry.")
                         );
        continue;
      }
      if( ! Popup::YesNo( sformat( // Question of a Popup::YesNo
                                   // where %1 will be replaced by the driver name:
                                   _("Deactivate %1?"), backend_name ) ) )
      { continue;
      }
      Wizard::DisableNextButton();
      if( ! Scanner::DeactivateBackend( backend_name, -1, true ) )
      { Popup::Error( // Message of a Popup::Error
                      // where %1 will be replaced by the driver (backend) name.
                      // Only a simple message because before the function Scanner::DeactivateBackend
                      // was called and this function would have shown more specific messages.
                      sformat( _("Failed to deactivate %1."), backend_name ) );
      }
      Wizard::EnableNextButton();
      // Exit this dialog and run it again via the sequencer in wizards.ycp
      // to get it updated after the delete via calling OverviewContents():
      ret = `delete;
      break;
    }
    /* test */
    if( ret == `test )
    { // Get what was selected:
      string selected_item_id = WizardHW::SelectedItem();
      y2milestone( "Selected item id in OverviewDialog: %1", selected_item_id );
      if( selected_item_id == "" )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when nothing was selected:
                           _("Nothing Selected"),
                           // Body of a Popup::AnyMessage when nothing was selected:
                           _("Select an entry.")
                         );
        continue;
      }
      // The selected_item_id can be one of the following (see the OverviewContents function):
      // "autodetected_scanner:[0-9]*" where [0-9]* is the autodetected_scanners_index
      // (i.e. the index in the autodetected_scanners list to which the selected item matches)
      // "active_scanner:[0-9]*" where [0-9]* is the active_scanners_index
      // (i.e. the index in the active_scanners list to which the selected item matches)
      // "active_backend:[0-9]*" where [0-9]* is the active_backends_index
      // (i.e. the index in the active_backends list to which the selected item matches)
      // "nothing" which is used as fallback only if none of the above was set
      // (i.e. if neither a scanner was autodetected nor an active scanner nor an active backend exists)
      if( issubstring( selected_item_id, "autodetected_scanner:" ) )
      { // A selected autodetected scanner (which is not yet configured) cannot be tested.
        // A selected autodetected scanner can be edited.
        Popup::AnyMessage( // Header of a Popup::AnyMessage when an autodetected scanner
                           // which is not yet configured was selected
                           // and then the user clicked the [Test] button.
                           // Translate 'Test' to the exact label of the [Test] button.
                           _("Test Not Possible"),
                           // Body of a Popup::AnyMessage when an autodetected scanner
                           // which is not yet configured was selected
                           // and then the user clicked the [Test] button:
                           // Translate 'edit' to the exact label of the [Edit] button.
                           _("It is only possible to edit a detected scanner.")
                         );
        continue;
      }
      if( issubstring( selected_item_id, "active_backend:" ) )
      { // A selected active backend without a matching active scanner cannot be tested.
        // A selected active backend without a matching active scanner can only be deleted.
        Popup::AnyMessage( // Header of a Popup::AnyMessage when an active driver
                           // without a matching active scanner was selected
                           // and then the user clicked the [Test] button.
                           // Translate 'Test' to the exact label of the [Test] button.
                           _("Test Not Possible"),
                           // Body of a Popup::AnyMessage when an active driver
                           // without a matching active scanner was selected
                           // and then the user clicked the [Test] button:
                           // Translate 'delete' to the exact label of the [Delete] button.
                           _("It is only possible to delete a driver without a matching scanner.")
                         );
        continue;
      }
      if( "nothing" == selected_item_id )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when there is only the fallback entry
                           // when there is neither a detected scanner nor an active scanner or driver
                           // and then the user clicked the [Test] button.
                           // Translate 'Test' to the exact label of the [Test] button.
                           _("Test Not Possible"),
                           // Body of a Popup::AnyMessage when there is only the fallback entry
                           // when there is neither a detected scanner nor an active scanner or driver
                           // and then the user clicked the [Test] button.
                           // Translate 'add' to the exact label of the [Add] button.
                           _("It is only possible to add a scanner.")
                         );
        continue;
      }
      if( issubstring( selected_item_id, "active_scanner:" ) )
      { // Test a selected active scanner:
        integer active_scanners_index = tointeger( filterchars( selected_item_id, "0123456789" ) );
        string backend_name = Scanner::active_scanners[active_scanners_index,"backend"]:"";
        y2milestone( "Selected backend to be tested is: %1", backend_name );
        if( nil == backend_name
            || "" == backend_name )
        { Popup::AnyMessage( // Header of a Popup::AnyMessage when nothing was selected:
                             _("Nothing Selected"),
                             // Body of a Popup::AnyMessage when nothing was selected:
                             _("Select an entry.")
                           );
          continue;
        }
        if( ! Scanner::TestBackend( backend_name ) )
        { Popup::Error( // Message of a Popup::Error where %1 will be replaced by the driver (backend) name.
                        // Only a simple message because before the function Scanner::TestBackend
                        // was called and this function would have shown more specific messages.
                        sformat( _("Failed to test %1."), backend_name ) );
        }
      }
      // Exit this dialog and run it again via the sequencer in wizards.ycp
      // to get it updated after the test via calling OverviewContents().
      // Even if normally nothing in the dialog content should have changed
      // because of a test, it might have happened that for example
      // during the test somehow the USB or SCSI system had crashed
      // and then the scanner would be no longer an active scanner.
      ret = `test;
      break;
    }
    /* network scanning */
    if( ret == `network_scanning )
    { // Exit this dialog and run the ConfigureNetworkScanningDialog via the sequencer in wizards.ycp:
      break;
    }
    /* restart the whole autodetection */
    if( ret == `restart_detection )
    { // Toggle autodetection behaviour (initially ignore_unknown_USB_scanners == true):
      if( Scanner::ignore_unknown_USB_scanners )
      { // Show all USB devices with the device class 255 as possible USB scanners:
        Scanner::ignore_unknown_USB_scanners = false;
      }
      else
      { // Show only USB scanners for which the USB IDs are known in the database:
        Scanner::ignore_unknown_USB_scanners = true;
      }
      // Scanner::RestartDetection results true in any case, see the function comment.
      Scanner::RestartDetection();
      // Exit this dialog and run it again via the sequencer in wizards.ycp
      // to show the new autodetection results:
      break;
    }
    /* run hp-setup */
    if( ret == `run_hpsetup )
    { // Run hp-setup and wait until it is finished before the autodetection is restarted.
      // Scanner::RunHpsetup() returns false only if hp-setup cannot be run.
      // It returns true in any other case because there is no usable exit code of hp-setup
      // (always zero even in case of error).
      // The hp-setup exit code does not matter because the autodetection will show
      // an appropriate result (e.g. no HP all-in-one device if hp-setup failed):
      if( ! Scanner::RunHpsetup() )
      { Popup::Error( // Message of a Popup::Error.
                      // Only a simple message because before the function Scanner::RunHpsetup
                      // was called and this function would have shown more specific messages.
                      // Do not change or translate "hp-setup", it is a program name:
                      _("Failed to run hp-setup.")
                    );
        continue;
      }
      // Scanner::RestartDetection results true in any case, see the function comment.
      Scanner::RestartDetection();
      // Exit this dialog and run it again via the sequencer in wizards.ycp
      // to show the new autodetection results:
      break;
    }
    y2milestone( "Ignoring unexpected returncode in OverviewDialog: %1", ret );
    continue;
  }
  y2milestone( "OverviewDialog returns: %1", ret );
  return ret;
}

/**
 * Select model dialog
 * @return dialog result
 */
any SelectModelDialog()
{ // Caption of the SelectModelDialog:
  string caption = _("Scanner Model and Driver Selection");
  // If there is an autodetected scanner selected
  // then preset the filter_string with the autodetected manufacturer
  // if the autodetected manufacturer exists in the database
  // to avoid an empty model selection list.
  // If there is no autodetected manufacturer or if its value is the empty string
  // or if the autodetected manufacturer does not exist in the database
  // then the empty filter_string results no filtering at all:
  string filter_string = "";
  if( Scanner::selected_autodetected_scanners_index >= 0 )
  { string autodetected_manufacturer = Scanner::autodetected_scanners[Scanner::selected_autodetected_scanners_index,"manufacturer"]:"";
    string autodetected_connection = Scanner::autodetected_scanners[Scanner::selected_autodetected_scanners_index,"connection"]:"";
    // Unify known ambiguous autodetected manufacturer names:
    if( "hp" == tolower( autodetected_manufacturer ) )
    { autodetected_manufacturer = "Hewlett-Packard";
    }
    // Preset the filter_string only if the autodetected manufacturer exists in the database.
    // The leading "^" avoids to find entries which do not really belong to this manufacturer
    // (e.g. when the manufacturer name is mentioned only in a comment of another model)
    // because the actual manufacturer name is the first part of the model string.
    // The trailing ".*" is only to have a user-friendly preset regular expression
    // so that it works when the user simply appends more stuff (e.g. a part of the model name):
    foreach( string database_manufacturer,
             Scanner::database_manufacturers,
             { if( tolower( database_manufacturer ) == tolower( autodetected_manufacturer ) )
               { filter_string = "^" + autodetected_manufacturer + ".*";
               }
             }
           );
    // If it is an autodetected SCSI scanner, append "\(SCSI" to the filter_string
    // (the filter_string may be the empty string if no manufacturer matched above)
    // to suppress that tons of USB-only scanners are also shown to the user.
    // The "(" is used to match only to the interface_and_usbid_string (see Scanner.ycp)
    // to avoid that plain "SCSI" is found when it is only mentioned in a comment but actually
    // no "SCSI" is specified as supported interface in the description file (e.g. see avision.desc).
    // One "\" is needed to quote the "(" which has a special meaning in a regular expression and
    // the leftmost "\" is needed to quote the next "\" which has a special meaning in YCP strings.
    if( "SCSI" == autodetected_connection )
    { filter_string = filter_string + "\\(SCSI";
    }
  }
  term contents = `VBox( `HBox( `TextEntry( `id(`filter_input),
                                            // Header of a TextEntry user input field to enter a search string:
                                            _("S&earch String"),
                                            filter_string
                                          ),
                                `PushButton( `id(`apply_filter),
                                             // This button must be the default
                                             // (it is activated when the user pressed the Enter key)
                                             // because when the user has clicked into TextEntry to enter something
                                             // it is normal to finish entering by pressing the Enter key
                                             // but if the Enter key was linked to 'Next' or 'Back',
                                             // the user would get the wrong action.
                                             `opt(`default),
                                             // Label of a PushButton to search a list for a search string:
                                             _("&Search")
                                           ),
                                `PushButton( `id(`ignore_filter),
                                             // Label of a PushButton to show all entries of a list:
                                             _("Show Complete &List")
                                           )

                              ),
                         `ReplacePoint( `id(`model_selection_replace_point),
                                        `SelectionBox( `id(`model_selection),
                                                       // Header of a SelectionBox with a list of models:
                                                       _("Scanner &Models"),
                                                       Scanner::ModelItems( filter_string )
                                                     )
                                      )
                       );
  Wizard::SetContentsButtons( caption,
                              contents,
                              HELPS["select_model"]:"",
                              Label::BackButton(),
                              Label::NextButton()
                            );
  // According to http://en.opensuse.org/YaST/Style_Guide#Configuration_Wizard
  // the button with the "back" functionality must be disabled
  // only when it is the first dialog of a wizard stlye dialog sequence.
  Wizard::HideBackButton();
  // According to http://en.opensuse.org/YaST/Style_Guide#Configuration_Wizard
  // there is no longer a "abort" functionality which exits the whole module.
  // Instead this button is now named "Cancel" and its functionality is
  // to go back to the Overview dialog (i.e. what the "back" button would do)
  // because it reads "Cancel - Closes the window and returns to the overview."
  Wizard::SetAbortButton( `back, Label::CancelButton() );
  any ret = nil;
  while(true)
  { ret = UI::UserInput();
    if ( ret == `back )
    { break;
    }
    /* apply a filter to the model list */
    if( ret == `apply_filter )
    { filter_string = (string)UI::QueryWidget( `id(`filter_input), `Value );
      UI::ReplaceWidget( `id(`model_selection_replace_point),
                         `SelectionBox( `id(`model_selection),
                                        // Header of a SelectionBox with a list of models:
                                        _("Scanner &Models"),
                                        Scanner::ModelItems( filter_string )
                                      )
                       );
      continue;
    }
    /* ignore the filter for the model list */
    if( ret == `ignore_filter )
    { filter_string = (string)UI::QueryWidget( `id(`filter_input), `Value );
      UI::ReplaceWidget( `id(`model_selection_replace_point),
                         `SelectionBox( `id(`model_selection),
                                        // Header of a SelectionBox with the complete list of models:
                                        _("All Scanner &Models"),
                                        Scanner::ModelItems( "" )
                                      )
                       );
      continue;
    }
    /* select a scanner */
    if( ret == `next )
    { Scanner::selected_model_database_index = (integer)UI::QueryWidget( `id(`model_selection), `CurrentItem );
      if( nil == Scanner::selected_model_database_index )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no model was selected:
                           _("Nothing Selected"),
                           // Body of a Popup::AnyMessage when no model was selected:
                           _("Select an entry.")
                         );
        continue;
      }
      // Compare how the ModelItems function builds the matching status_strings by using the same logic:
      if( "unsupported" == Scanner::database[Scanner::selected_model_database_index,"status"]:"unknown" )
      { string backend = Scanner::database[Scanner::selected_model_database_index,"backend"]:"unknown";
        if( "unsupported" == backend )
        { Popup::AnyMessage( // Header of a Popup::AnyMessage when an unsupported model was selected:
                             _("Unsupported Model"),
                             // Body of a Popup::AnyMessage when an unsupported model was selected:
                             _("This model is not supported.\nAsk the manufacturer for a Linux driver.")
                           );
        }
        else
        { Popup::AnyMessage( sformat( // Header of a Popup::AnyMessage when a model was selected
                                      // which is listed as "unsupported" for a particular driver:
                                      // %1 will be replaced by the backend (scanner driver) name
                                      _("Model Not Supported by the Driver %1"),
                                      backend
                                    ),
                             // Body of a Popup::AnyMessage when a model was selected
                             // which is listed as "unsupported" for a particular driver:
                             _("Check if another driver supports it,\nselect a compatible model,\nor ask the manufacturer for a Linux driver.")
                           );
        }
        continue;
      }
      // The epkowa backend in the package iscan-free is available for all architectures.
      // In contrast the epkowa backend in the package iscan which is provided by Avasys
      // is only available for i386-compatible architectures:
      // True 32-bit i386 and also 64-bit x86_64.
      // For some models it might be only available for 32-bit i386 architecture.
      // Some scanners require additionally proprietary libraries which are
      // provided by Avasys as additional model dependant iscan-plugin-<model-name> RPMs.
      // For those scanners there is in the database "backend"="epkowa" and "package"="iscan".
      // The scanners which work with iscan-free have "backend"="epkowa" and "package"="iscan-free".
      // It would be possible to test for non-i386-compatible architecture in the ModelItems function
      // and suppress the epkowa backend entries in the model list but intentionally this is not done.
      // All available known model information is always shown to the user.
      // There is never known information secretly hidden from the user.
      // If something is not supported in a special case, an additional information message is shown.
      // Otherwise a user on a non-i386-compatible architecture would not understand
      // when others (who use i386) tell him that "model XYZ is listed and works perfectly"
      // until after a long discusssion they find out that it depends on the architecture.
      if( "epkowa" == Scanner::database[Scanner::selected_model_database_index,"backend"]:"unknown"
          && "iscan" == Scanner::database[Scanner::selected_model_database_index,"package"]:"unknown"
          && ! Arch::i386()
        )
      { if( ! Arch::x86_64() )
        { Popup::AnyMessage( // Header of a Popup::AnyMessage when the epkowa driver was selected
                             // on a non-i386-compatible architecture (i.e. neither i386 nor x86_64).
                             _("Unsupported Driver"),
                             // Body of a Popup::AnyMessage when the epkowa driver was selected
                             // on a non-i386-compatible architecture (i.e. neither i386 nor x86_64).
                             // Do not change or translate "epkowa", it is a driver name.
                             // Do not change or translate "i386", it is an architecture name.
                             _("The epkowa driver is only available for i386-compatible architectures (32-bit i386 and also 64-bit x86_64).")
                           );
          continue;
        }
        if( ! Popup::ContinueCancelHeadline( // Header of a Popup::ContinueCancelHeadline
                                             // when the epkowa driver was selected on x86_64:
                                             _("Possibly Problematic Driver"),
                                             // Body of a Popup::ContinueCancelHeadline
                                             // when the epkowa driver was selected on x86_64.
                                             // Do not change or translate "epkowa", it is a driver name.
                                             _("The epkowa driver may cause problems on 64-bit x86_64 architecture.")
                                           )
          )
        { // The user has decided to cancel the set up of the epkowa backend on x86_64:
          continue;
        }
      }
      // Tell the user that the hpoj backend is outdated and no longer maintained:
      if( "hpoj" == Scanner::database[Scanner::selected_model_database_index,"backend"]:"unknown" )
      { if( ! Popup::ContinueCancelHeadline( // Header of a Popup::ContinueCancelHeadline
                                             // when the outdated hpoj driver was selected:
                                             _("Outdated Driver"),
                                             // Body of a Popup::ContinueCancelHeadline
                                             // when the outdated hpoj driver was selected.
                                             // Do not change or translate "hpoj", it is a driver name.
                                             // Do not change or translate "hpaio", it is a driver name.
                                             _("The hpoj driver should work but it is no longer maintained.\nTry to use the up-to-date driver hpaio.")
                                           )
          )
        { // The user has decided to cancel the set up of the outdated hpoj backend:
          continue;
        }
      }
      // Leve this dialog and do the "next" step according to the sequences in wizards.ycp:
      break;
    }
    y2milestone( "Ignoring unexpected returncode in SelectModelDialog: %1", ret );
    continue;
  }
  return ret;
}

/**
 * Configure backend dialog
 * @return dialog result
 */
any ConfigureBackendDialog()
{ // Caption of the ConfigureBackendDialog:
  string caption = _("Scanner and Driver Setup");
  y2milestone( "Selected model is: %1", Scanner::database[Scanner::selected_model_database_index]:$[] );
  string backend_name = Scanner::database[Scanner::selected_model_database_index,"backend"]:"unknown";
  // The content here is only a dummy.
  // The real content is what the "Progress:..." shows in ActivateBackend().
  term contents = `Label( "" );
  // According to http://en.opensuse.org/YaST/Style_Guide#Configuration_Wizard
  // the button with the "back" functionality is unchanged
  // when it is not the first dialog of a wizard stlye dialog sequence.
  // According to http://en.opensuse.org/YaST/Style_Guide#Configuration_Wizard
  // the last "next" button of a wizard-style dialog sequence must be named "finish":
  Wizard::SetContentsButtons( caption,
                              contents,
                              HELPS["configure_backend"]:"",
                              Label::BackButton(),
                              Label::FinishButton()
                            );
  // According to http://en.opensuse.org/YaST/Style_Guide#Configuration_Wizard
  // there is no longer a "abort" functionality which exits the whole module
  // for a wizard stlye dialog sequence.
  // Instead within a wizard stlye dialog sequence the button with the
  // "abort" functionality is now named "Cancel" and it does not abort the whole module
  // but goes back to the Overvied dialog because it reads
  // "Cancel - Closes the window and returns to the overview."
  // But in this special case it does not make sense to just return to the overview
  // because it is not clear if the right now enabled backend should be disabled
  // (the same backend could be already used for another scanner)
  // so that I do not show any "abort"/"cancel" button here at all:
  Wizard::HideAbortButton();
  Wizard::DisableBackButton();
  Wizard::DisableNextButton();
  if( ! Scanner::ActivateBackend( "", Scanner::selected_model_database_index, true ) )
  { Popup::Error( sformat( // Message of a Popup::Error where %1 will be replaced by the driver (backend) name.
                           // Only a simple message because before the function Scanner::ActivateBackend
                           // was called and this function would have shown more specific messages.
                           _("Failed to activate %1."), backend_name ) );
    Wizard::EnableBackButton();
    Wizard::EnableNextButton();
  }
  else
  { // Wait two seconds so that the user can notice that Scanner::ActivateBackend(...) was successful
    // and then automatically proceed to the 'next' dialog which is the overview dialog.
    // Therefore there is no way 'back' when Scanner::ActivateBackend(...) was successful
    // (which makes sense because why should the user undo right now what was successful)
    // so that 'back' is only possible if Scanner::ActivateBackend(...) failed or when it
    // was aborted by the user (e.g. when the user aborted to install a required package):
    Wizard::EnableNextButton();
    sleep( 2000 );
    UI::FakeUserInput( `next );
  }
  any ret = nil;
  while(true)
  { ret = UI::UserInput();
    if( ret == `back )
    { Wizard::DisableBackButton();
      Wizard::DisableNextButton();
      if( ! Scanner::DeactivateBackend( "", Scanner::selected_model_database_index, false ) )
      { Popup::Error( sformat( // Message of a Popup::Error where %1 will be replaced by the driver (backend) name.
                               // Only a simple message because before the function Scanner::DeactivateBackend
                               // was called and this function would have shown more specific messages.
                               _("Failed to deactivate %1."), backend_name ) );
      }
      Wizard::EnableBackButton();
      Wizard::EnableNextButton();
      break;
    }
    if( ret == `next )
    { break;
    }
    y2milestone( "Ignoring unexpected returncode in ConfigureBackendDialog: %1", ret );
    continue;
  }
  return ret;
}

/**
 * Network scanning dialog
 * @return dialog result
 */
any ConfigureNetworkScanningDialog()
{ boolean firewall_popup_was_shown = false;
  // Determine the network scanning config
  // but don't care if this fails because then empty strings are used as secure fallback
  // and empty strings will disable scanning via network (i.e. the net backend and the saned):
  Scanner::DetermineNetworkScanningConfig();
  string net_backend_hosts = Scanner::network_scanning_config["net_backend_hosts"]:"";
  string saned_hosts = Scanner::network_scanning_config["saned_hosts"]:"";
  // Caption of the ConfigureNetworkScanningDialog:
  string caption = _("Set Up Scanning via Network");
  // Header of a TextEntry user input field.
  // Do not change or translate "saned", it is a program (sane daemon) name.
  string saned_hosts_input_label = _("Permitted &Clients for saned");
  // Header of a TextEntry user input field.
  // Do not change or translate "net", it is a metadriver name.
  // Do not simply use "driver" because net is no normal driver but a metadriver.
  string net_backend_hosts_input_label = _("&Servers Used for the net Metadriver");
  // Predefibed values for the so called "local host configuration":
  // The trailing ',' is intentional:
  // It results a nice linefed at the end of the config file and
  // the user can simply append something without the need to add a ',' as seperator:
  string saned_hosts_input_local_host_config_value = "127.0.0.0/8,";
  string net_backend_hosts_input_local_host_config_value = "localhost,";
  // All contenst of the scanning via network dialog:
  term contents = `VBox( `VStretch(),
                         `Frame( // Label of a Frame for the server settings for scanning via network.
                                 _("Server Settings"),
                                 `TextEntry( `id(`saned_hosts_input),
                                             saned_hosts_input_label,
                                             saned_hosts
                                           )
                               ),
                         `VStretch(),
                         `Frame( // Label of a Frame for the client settings for scanning via network.
                                 _("Client Settings"),
                                 `TextEntry( `id(`net_backend_hosts_input),
                                             net_backend_hosts_input_label,
                                             net_backend_hosts
                                           )
                               ),
                         `VStretch(),
                         `Frame( // Label of a Frame for predefined configurations.
                                 _("Predefined Configurations"),
                                 `VBox( `Left( `PushButton( `id(`local_host_config),
                                                            // Label of a PushButton for a predefined configuration.
                                                            // Be careful when you change or translate "local host configuration"
                                                            // because this term is used also in the help text
                                                            // and in a message of a Popup::ContinueCancel
                                                            _("&Local Host Configuration")
                                                          )
                                             ),
                                        `Left( `PushButton( `id(`disable_scanning_via_network),
                                                            // Label of a PushButton to disable scanning via network.
                                                            // Do not confuse "scanning via network"
                                                            // (i.e. use a remote scanner via another host in the network)
                                                            // with "scanning the network"
                                                            // (i.e. scan the network for other hosts or services).
                                                            _("&Disable Scanning via Network")
                                                          )
                                             )
                                      )
                               ),
                         `VStretch()
                       );
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // there is no longer a "abort" functionality which exits the whole module.
  // Instead this button is now named "Cancel" and its functionality is
  // to go back to the Overview dialog (i.e. what the "back" button would do)
  // because it reads "Cancel - Closes the window and returns to the overview."
  // Therefore the button with the "abort" functionality is not shown at all
  // and the button with the "back" functionality is named "Cancel".
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // the "finish" button in a single (step) configuration dialog must now be named "OK".
  Wizard::SetContentsButtons( caption,
                              contents,
                              HELPS["configure_network_scanning"]:"",
                              Label::CancelButton(),
                              Label::OKButton()
                            );
  Wizard::HideAbortButton();
  if( ( "" != filterchars( net_backend_hosts, Scanner::alnum_chars )
        || "" != filterchars( saned_hosts, Scanner::alnum_chars )
      )
      &&
      ( net_backend_hosts_input_local_host_config_value != net_backend_hosts
        || saned_hosts_input_local_host_config_value != saned_hosts
      )
    )
  { // When the current net_backend_hosts value is effectively non-empty
    // or when the current saned_hosts value is effectively non-empty
    // and when at least one is not only those of a "Local Host Configuration"
    // test whether or not a firewall seems to be active and
    // if yes show a popup regarding firewall:
    if( Scanner::ShowFirewallPopup() )
    { firewall_popup_was_shown = true;
    }
  }
  any ret = nil;
  while(true)
  { ret = UI::UserInput();
    /* local host configuration */
    if( ret == `local_host_config )
    { UI::ChangeWidget( `id(`saned_hosts_input),
                        `Value,
                        saned_hosts_input_local_host_config_value
                       );
      UI::ChangeWidget( `id(`net_backend_hosts_input),
                        `Value,
                        net_backend_hosts_input_local_host_config_value
                       );
      continue;
    }
    /* disable scanning via network */
    if( ret == `disable_scanning_via_network )
    { UI::ChangeWidget( `id(`saned_hosts_input),
                        `Value,
                        ""
                       );
      UI::ChangeWidget( `id(`net_backend_hosts_input),
                        `Value,
                        ""
                       );
      continue;
    }
    /* set up the configuration */
    if( ret == `next )
    { // Get the mandatory vaules to set up scanning via network:
      net_backend_hosts = (string)UI::QueryWidget( `id(`net_backend_hosts_input), `Value );
      saned_hosts = (string)UI::QueryWidget( `id(`saned_hosts_input), `Value );
      if( ( "" != filterchars( net_backend_hosts, Scanner::alnum_chars )
            || "" != filterchars( saned_hosts, Scanner::alnum_chars )
          )
          &&
          ( net_backend_hosts_input_local_host_config_value != net_backend_hosts
            || saned_hosts_input_local_host_config_value != saned_hosts
          )
        )
      { // When the current net_backend_hosts value is effectively non-empty
        // or when the current saned_hosts value is effectively non-empty
        // and when at least one is not only those of a "Local Host Configuration"
        // test whether or not a firewall seems to be active and
        // if yes show a popup regarding firewall if it was not yet shown:
        if( ! firewall_popup_was_shown )
        { if( Scanner::ShowFirewallPopup() )
          { firewall_popup_was_shown = true;
          }
        }
      }
      Scanner::network_scanning_config["net_backend_hosts"] = net_backend_hosts;
      Scanner::network_scanning_config["saned_hosts"] = saned_hosts;
      Wizard::DisableBackButton();
      Wizard::DisableNextButton();
      if( ! Scanner::SetupNetworkScanningConfig() )
      { Wizard::EnableBackButton();
        Wizard::EnableNextButton();
        continue;
      }
      Wizard::EnableBackButton();
      Wizard::EnableNextButton();
      break;
    }
    if( ret == `back )
    { break;
    }
    y2milestone( "Ignoring unexpected returncode in ConfigureNetworkScanningDialog: %1", ret );
    continue;
  }
  return ret;
}

/* EOF */

}

