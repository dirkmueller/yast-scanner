/**
 * File:        modules/Scanner.ycp
 * Package:     Configuration of scanner
 * Summary:     Scanner settings, input and output functions
 * Authors:     Johannes Meixner <jsmeix@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of scanner.
 * Input and output routines.
 */

{

module "Scanner";
textdomain "scanner";

import "Progress";
import "Report";
import "Summary";
import "Popup";
import "Package";
import "Label";
import "Service";
import "SuSEFirewall";
import "Arch";

/**
 * Something was committed to the system?
 * True if system may have been modified.
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Something was committed to the system?
 * @return true if system may have been modified
 */
global boolean Modified()
{ return modified;
}

/**
 * Abort function
 * @return true if not modified and user requested abort
 */
global boolean Abort()
{ return !Modified() && UI::PollInput() == `abort;
}

// Settings:
// Define all variables needed for configuration of scanner:

/**
 * Explicite listing of all alphanumeric ASCII characters.
 * The reason is that in certain special locales for example [a-z] is not equivalent
 * to "abcdefghijklmnopqrstuvwxyz" because in certain special languages the 'z' is
 * not the last character in the alphabet, e.g. the Estonian alphabet ends
 * with ... s ... z ... t u v w ... x y (non-ASCII characters omitted here)
 * so that [a-z] would exclude t u v w x y in an Estonian locale.
 * Therefore uppercase and lowercase characters are both explicitely listed
 * to avoid any unexpected result e.g. of "tolower(uppercase_characters)".
 */
global string number_chars = "0123456789";
global string upper_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
global string lower_chars = "abcdefghijklmnopqrstuvwxyz";
global string letter_chars = upper_chars + lower_chars;
global string alnum_chars = number_chars + letter_chars;
global string lower_alnum_chars = number_chars + lower_chars;

/**
 * Scanner database:
 * When package version of sane-backends/hplip/iscan/iscan-free changes
 * the database is created anew in Scanner::Read() which calls the bash script
 * "/usr/lib/YaST2/bin/create_scanner_database YCP"
 * which outputs on stdout a YCP list of @ref scanner_model_map
 * where the last list entry is an emtpy map.
 * @struct scanner_model_map
 * $[ "package":"The package which provides the backend: sane-backends/hplip/iscan/iscan-free (required)",
 *    "backend":"The name of the backend (required)",
 *    "manufacturer":"The manufacturer name of the scanner (required)",
 *    "model":"The model name of the scanner (required)",
 *    "firmware":"Whether or not firmware upload is required (value is 'required' or the empty string)",
 *    "interface":"None or one or more scanner interfaces (may be the empty string)",
 *    "usbid":"USBvendorID:USBproductID" e.g. "0x0a1b:0x2c3d" (may be the empty string)",
 *    "status":"The support status: basic/complete/good/minimal/unsupported/untested (required)",
 *    "comment":"An optional comment (may be the empty string)"
 *  ]
 */
global list< map< string, string > > database = [];

/**
 * Manufacturer list:
 * List of unique manufacturer names.
 * Derived during startup from the scanner database
 * (in the Read function stage "Read or create the scanner database").
 */
global list< string > database_manufacturers = [];

/**
 * Known USB scanner USB IDs list:
 * List of known USB scanner USB vendor and product IDs.
 * Derived during startup from the scanner database
 * (in the Read function stage "Read or create the scanner database").
 */
global list< string > database_usbids = [];

/**
 * Active scanners:
 * Determined at runtime via Scanner::DetermineActiveScanners() which calls the bash script
 * "/usr/lib/YaST2/bin/determine_active_scanners YCP"
 * which outputs on stdout a YCP list of @ref active_scanner_map
 * where the last list entry is an emtpy map.
 * @struct active_scanner_map
 * $[ "backend":"The name of the backend (required)",
 *    "sane_device":"The SANE device (required)",
 *    "manufacturer":"The manufacturer name of the scanner (required)",
 *    "model":"The model name of the scanner (required)",
 *  ]
 */
global list< map< string, string > > active_scanners = [];

/**
 * Active backends:
 * Determined at runtime via Scanner::DetermineActiveBackends() which calls the bash script
 * "/usr/lib/YaST2/bin/determine_active_scanner_backends YCP"
 * which outputs on stdout a YCP list of backends
 * [ "The name of the backend", ... "" ]
 * where the last list entry is an empty string.
 */
global list< string > active_backends = [];

/**
 * Autodetected scanners:
 * Determined at runtime via Scanner::AutodetectScanners()
 * which calls the bash script /usr/lib/YaST2/bin/autodetect_scanners YCP
 * which calls "sane-find-scanner" and (if available) "hp-probe"
 * which may result for example the description strings in the example below.
 * Only in case of USB an automated extraction of manufacturer is possible.
 * If there are two '[...]' substrings then the first one is the manufacturer
 * and the second one is the model (but there may be only one or none substring).
 * The result is a YCP list of @ref autodetected_scanner_map
 * where the last list entry is an emtpy map.
 * @struct autodetected_scanner_map
 * $[ "connection":"Either USB or SCSI or NETWORK (required)",
 *    "device":"The device, e.g. '/dev/sg0' or 'libusb:001:002' (may be the empty string)"
 *    "manufacturer":"The manufacturer name of the scanner (may be the empty string)",
 *    "usb_vendor_id":"The vendor ID (e.g. 0x04b8) of a USB scanner (may be the empty string)",
 *    "model":"The model name of the scanner (may be the empty string)",
 *    "usb_product_id":"The product ID (e.g. 0x010b) of a USB scanner (may be the empty string)",
 *    "description":"The sane-find-scanner output description string (required)"
 *  ]
 * @example
 * SCSI processor 'HP C6270A 3846' at /dev/sg0
 * USB scanner (vendor=0x05da, product=0x20b0) at libusb:002:005
 * USB scanner (vendor=0x03f0 [Hewlett-Packard], product=0x0201 [HP ScanJet 6200C]) at libusb:002:006
 * USB scanner (vendor=0x04a9 [Canon], product=0x220e [CanoScan], chip=LM9832/3) at libusb:001:005
 * USB scanner (vendor=0x04b8 [EPSON], product=0x010b [Perfection1240]) at libusb:001:004
 * USB scanner (vendor=0x03f0 [HP], product=0x0000 [HP LaserJet 1220])
 * NETWORK scanner (vendor [HP], product [Officejet 7200 series])
 */
global list< map< string, string > > autodetected_scanners = [];

/**
 * Network scanning configuration:
 * Determined at runtime via Scanner::DetermineNetworkScanningConfig() which calls the bash script
 * "/usr/lib/YaST2/bin/determine_network_scanner_config YCP"
 * which outputs on stdout a YCP map @ref network_scanner_config
 * @struct network_scanner_config
 * $[ "net_backend_hosts":"Comma seperated list of hosts in /etc/sane.d/net.conf",
 *    "saned_hosts":"Comma seperated list of hosts or subnets in /etc/sane.d/saned.conf"
 *  ]
 */
global map< string, string > network_scanning_config = $[];

/**
 * Firewall network scanning configuration:
 * Determined at runtime via Scanner::DetermineNetworkScanningConfig()
 * which calls SuSEFirewall functions to fill the map @ref firewall_config
 * except "ui_no_firewall_for_int" and "ui_deny_from_ext" which are the user settings in the dialog.
 * The entries are such that "true" is the default, reasonable and intended setting.
 * @struct firewall_config
 * $[ "suse_firewall_used":"true if Suse Firewall and no other firewall is used",
 *    "firewall_active":"true if Suse Firewall is actually running",
 *    "no_firewall_for_int":"true if Suse Firewall does not potect the INT zone",
 *    "ui_no_firewall_for_int":"true if user has set in dialog no Suse Firewall protection for INT",
 *    "denied_from_ext":"true if saned access (sane-port 6566) is denied from EXT zone",
 *    "ui_deny_from_ext":"true if user has set in dialog to deny access from EXT"
 *  ]
 */
global map< string, boolean > firewall_config = $[];

/**
 * Environment values:
 * It is a map of @ref environment_values
 * @struct environment_values
 * $[ "sane-backends_version":"What 'rpm -q sane-backends' returns (required)",
 *    "hplip_version":"What 'rpm -q hplip' returns (required)",
 *    "iscan_version":"What 'rpm -q iscan' returns (required)"
 *    "iscan-free_version":"What 'rpm -q iscan-free' returns (required)"
 *  ]
 */
global map< string, string > actual_environment = $[ "sane-backends_version":"",
                                                     "hplip_version":"",
                                                     "iscan_version":"",
                                                     "iscan-free_version":""
                                                   ];
global map< string, string > stored_environment = $[ "sane-backends_version":"",
                                                     "hplip_version":"",
                                                     "iscan_version":"",
                                                     "iscan-free_version":""
                                                   ];

/*
 * Other global variables:
 */

/**
 * Selected model database index:
 * The index in the scanner database list (of model maps)
 * for the model which was selected by the user in the SelectModelDialog.
 * Preset to -1 which indicates that no model is selected.
 */
global integer selected_model_database_index = -1;

/**
 * Selected autodetected scanners index:
 * The index in the autodetected scanners list (of autodetected scanner maps)
 * for the model which was selected by the user in the OverviewDialog.
 * Preset to -1 which indicates that no model is selected.
 */
global integer selected_autodetected_scanners_index = -1;

/**
 * Ignore unknown USB scanners:
 * Whether or not unknown USB scanners should be ignored during AutodetectScanners.
 * As there is no USB device class for scanners (they have the unspecific USB device class 255),
 * sane-find-scanner can only do some best guess to determine if a USB device is a scanner or not.
 * Therefore also other USB devices with the device class 255 are reported as possible USB scanners.
 * Preset to true so that initially only scanners for which the USB IDs are known by SANE are shown.
 * It changes to false (i.e. show all USB devices with the device class 255 as possible USB scanners)
 * when the user explicitely requests a "Restart Detection" in the OverviewDialog.
 * A second "Restart Detection" changes it back to true so that "Restart Detection" toggles it.
 * The idea behind is that the user can simply "Restart Detection" as often as he likes
 * until the result is o.k. for him because "Restart Detection" does not cause harm and
 * it avoids a separated button or check-box to determine the autodetection behaviour
 * which would require additional explanatory (complicated) help text about the whole stuff.
 * Examples:
 * Assume there is a known powered-off USB scanner and another USB device with class 255:
 * Initially nothing is shown.
 * After the first "Restart Detection" only the other USB device with class 255 is shown.
 * This unexpected result makes the user think about what is wrong and he powers-on the scanner.
 * After the second "Restart Detection" only the USB scanner is shown.
 * Assume there is an unknown powered-off USB scanner and another USB device with class 255.
 * Initially nothing is shown.
 * After the first "Restart Detection" only the other USB device with class 255 is shown.
 * This unexpected result makes the user think about what is wrong and he powers-on the scanner.
 * After the second "Restart Detection" nothing is shown.
 * A third "Restart Detection" shows both the USB scanner and the other USB device with class 255.
 * This is the best possible result because it is not possible to show only the unknown USB scanner.
 */
global boolean ignore_unknown_USB_scanners = true;

/*
 * Local variables:
 */
string environment_filename = "/var/lib/YaST2/stored_scanner_environment.ycp";
string database_filename = "/var/lib/YaST2/scanner_database.ycp";
string create_database_commandline = "/usr/lib/YaST2/bin/create_scanner_database YCP >" + database_filename;
string active_scanners_filename = "/var/lib/YaST2/active_scanners.ycp";
string determine_active_scanners_commandline = "/usr/lib/YaST2/bin/determine_active_scanners YCP >" + active_scanners_filename;
string active_backends_filename = "/var/lib/YaST2/active_scanner_backends.ycp";
string determine_active_scanner_backends_commandline = "/usr/lib/YaST2/bin/determine_active_scanner_backends YCP >" + active_backends_filename;
string autodetected_scanners_filename = "/var/lib/YaST2/autodetected_scanners.ycp";
string autodetect_scanners_commandline = "/usr/lib/YaST2/bin/autodetect_scanners YCP >" + autodetected_scanners_filename;
string activate_backend_commandline = "/usr/lib/YaST2/bin/activate_scanner_backend";
string deactivate_backend_commandline = "/usr/lib/YaST2/bin/deactivate_scanner_backend";
string test_backend_commandline = "/usr/lib/YaST2/bin/test_scanner_backend";
string setup_ptal_scanner_service_commandline = "/usr/lib/YaST2/bin/setup_ptal_scanner_service";
string setup_hplip_scanner_service_commandline = "/usr/lib/YaST2/bin/setup_hplip_scanner_service";
string network_scanning_config_filename = "/var/lib/YaST2/network_scanning_config.ycp";
string determine_network_scanning_config_commandline = "/usr/lib/YaST2/bin/determine_network_scanner_config YCP >" + network_scanning_config_filename;
string setup_network_scanning_config_commandline = "/usr/lib/YaST2/bin/setup_network_scanner_config";
string test_and_set_scanner_access_permissions_commandline = "/usr/lib/YaST2/bin/test_and_set_scanner_access_permissions";
// The result map is used as a simple common local store for whatever additional results
// (in particular commandline exit code, stdout, stderr, and whatever messages)
// so that the local functions in this module can be of	easy-to-use boolean type.
// The following keys are used:
// result["exit"]:<integer> for exit codes
// result["stdout"]:<string> for stdout and whatever non-error-messages
// result["stderr"]:<string> for stderr and whatever error-messages
map result = $[ "exit":0,
                "stdout":"",
                "stderr":""
              ];

/*
 * Local functions:
 */

/**
 * Unify various kind of a hexadecimal string like
 * "0x01a2", "0x1A2", "0x01A2" to one kind "0x1a2"
 * so that string comparison is possible:
 */
string UnifyHexString( string hexstring )
{ return tolower( tohexstring( tointeger( hexstring ) ) );
}

/**
 * Wrapper for SCR::Execute to execute a bash command to increase verbosity via y2milestone.
 * It reports the command via y2milestone in any case and it reports exit code, stdout
 * and stderr via y2milestone in case of non-zero exit code.
 * @param bash_commandline string of the bash command to be executed
 * @return true on success
 */
boolean ExecuteBashCommand( string bash_commandline )
{ y2milestone( "Executing bash commandline: %1", bash_commandline );
  result = (map)SCR::Execute( .target.bash_output, bash_commandline );
  if( result["exit"]:9999 != 0 )
  { y2milestone( "'%1' exit code is: %2", bash_commandline, result["exit"]:9999 );
    y2milestone( "'%1' stdout is: %2", bash_commandline, result["stdout"]:"" );
    y2milestone( "'%1' stderr is: %2", bash_commandline, result["stderr"]:"" );
    return false;
  }
  return true;
}

/**
 * Test whether an error message is meaningful (i.e. when it contains at least one letter character).
 * If yes, add a preceding "The error message is:" otherwise return the empty string.
 * @param error_message string of the error message
 * @return string of a meaningful error message with preceding "The error message is:" or "" otherwise
 */
string OnlyMeaningfulErrorMessage( string error_message )
{ if( "" !=  filterchars( error_message, letter_chars ) )
  { return sformat( // Only a simple message because it is only used
                    // to add a preceding "The error message is:" comment
                    // to display an error message where
                    // %1 will be replaced by the actual error message:
                    _("The error message is:\n\n%1"),
                    error_message
                  );
  }
  return "";
}

/**
 * Determine the version of an installed package by calling a bash command (rpm).
 * @param package_name string of the package name
 * @return string of the version of an installed package or "failed to determine" otherwise
 */
string InstalledPackageVersion( string package_name )
{ if( ! Package::Installed( package_name ) )
  { return "not installed";
  }
  if( ! ExecuteBashCommand( "/bin/rpm -q " + package_name + " | /usr/bin/tr -d '\n'" ) )
  { Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the package name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("Failed to determine the version of package %1."), package_name ) );
  }
  return result["stdout"]:"failed to determine";
}

/**
 * Test whether the package is installed (Package::Installed) and
 * if not then test whether the package is available to be installed (Package::Available) and
 * if yes then install it (Package::Install).
 * The packages iscan and iscan-free require special handling:
 * iscan and iscan-free conflict with each other,
 * iscan is only available on i386 compatible architectures
 * because iscan contains proprietary binary-only i386-only software,
 * some scanners require the non-free software.
 * @param package_name string of the package name
 * @return true on success
 */
boolean TestAndInstallPackage( string package_name )
{ // First of all the multi-line string because such strings cannot be indented:
  string iscan_message =
  // Message of a Report::Error
  // Do not change or translate "iscan", it is a package name.
  // Do not change or translate "i386", it is an architecture name.
_("The package iscan should be installed
but it contains proprietary binary-only i386-only software.
Therefore it is only available for i386-compatible architectures.
Some scanners are also supported by another driver.
If you really want to install iscan, you must do it manually.
");
  string iscan_64bit_message =
  // Do not change or translate "iscan", it is a package name.
  // Do not change or translate "x86_64", it is an architecture name.
  // Do not change or translate "AMD", it is a manufacturer name.
  // Do not change or translate "scanimage", it is a program name.
  // Do not change or translate "xscanimage", it is a program name.
  // Do not change or translate "xsane", it is a program name.
  // Do not change or translate "kooka", it is a program name.
_("Iscan is only available as 32-bit software.
On AMD 64-bit (x86_64) systems the scanner driver in the iscan package
works only if also the scanning user frontend is 32-bit software.
You can use the special frontend /usr/bin/iscan for Epson scanners
which is included in the iscan package.
If you like to use a standard frontend like scanimage, xscanimage, xsane, or kooka,
you must explicitely install the 32-bit package version
(i.e. get the package from the right media or repository).
");
  if( Package::Installed( package_name ) )
  { return true;
  }
  if( "iscan-free" == package_name
      && Package::Installed( "iscan" )
    )
  { // Each scanner which is supported by iscan-free is also supported by iscan.
    // If iscan is already installed, there is no need to switch to iscan-free.
    // Because iscan contains proprietary software it is not installed by default.
    // Therefore the user must have had installed iscan intentionally.
    return true;
  }
  if( "iscan" == package_name )
  { // Some scanners which are supported by iscan are not supported by iscan-free.
    // If iscan-free is already installed, it would have to be replaced by iscan.
    // Because iscan contains proprietary software this would be a replacement of free software
    // by proprietary software and this cannot be done in an automated way (as it would happen here).
    // Furthermore iscan is only available on i386 compatible architectures (on x86_64 only as 32-bit).
    // Finally on x86_64 the 32-bit iscan software cannot be used with the usual scanning frontends.
    // Therefore there is only a message and the user must do the installation manually.
    y2milestone( "No automated installation of proprietary iscan." );
    if( Arch::x86_64() )
    { iscan_message = iscan_message + "\n" + iscan_64bit_message;
    }
    Report::Error( iscan_message );
    return false;
  }
  // Is the package available to be installed?
  // Package::Available returns nil if no package source is available.
  boolean package_available = Package::Available( package_name );
  if( nil == package_available )
  { y2milestone( "Required package %1 is not installed and there is no package repository available.", package_name );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the package name:
                            _("Required package %1 is not installed and there is no package repository available."),
                            package_name
                          )
                 );
    return false;
  }
  if( ! package_available )
  { y2milestone( "Required package %1 is not installed and not available in the repository.", package_name );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the package name:
                            _("Required package %1 is not installed and not available in the repository."),
                            package_name
                          )
                 );
    return false;
  }
  if( ! Package::Install( package_name ) )
  { y2milestone( "Failed to install required package %1.", package_name );
    Report::Error( // Message of a Report::Error where %1 will be replaced by the package name.
                   // Only a simple message because:
                   // Either the user has explicitely rejected to install the package,
                   // or this error does not happen on a normal system
                   // (i.e. a system which is not totally broken or totally messed up).
                   sformat( _("Failed to install required package %1."),
                              package_name
                          )
                 );
    return false;
  }
  return true;
}

/**
 * Determine the active scanners by calling a bash script
 * which calls "scanimage -L" and processes its output
 * and stores the results as YCP list in a temporary file
 * and then read the temporary file (SCR::Read)
 * to get the YCP list of @ref active_scanner_map
 * @return true on success
 */
boolean DetermineActiveScanners()
{ if( ! ExecuteBashCommand( determine_active_scanners_commandline ) )
  { Report::Error( // Message of a Report::Error.
                   // Only a simple message because this error does not happen on a normal system
                   // (i.e. a system which is not totally broken or totally messed up).
                   // Do not confuse this error with the case when no active scanner was determined.
                   // The latter results no error.
                   _("Failed to determine the active scanners.")
                 );
    return false;
  }
  if( -1 == SCR::Read( .target.size, active_scanners_filename ) )
  { y2milestone( "Error: %1: file does not exist.", active_scanners_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("File %1 does not exist."),
                            active_scanners_filename
                          )
                 );
    return false;
  }
  active_scanners = (list< map< string, string > >)SCR::Read( .target.ycp, active_scanners_filename );
  if( nil == active_scanners )
  { y2milestone( "Error: Failed to read %1", active_scanners_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("Failed to read %1."),
                            active_scanners_filename
                          )
                 );
    active_scanners = [];
    return false;
  }
  y2milestone( "Active scanners: %1", active_scanners );
  return true;
}

/**
 * Determine the active backends by calling a bash script
 * which calls "grep ... /etc/sane.d/dll.conf" and processes its output
 * and stores the results as YCP list in a temporary file
 * and then read the temporary file (SCR::Read)
 * to get the YCP list of active backends.
 * @return true on success
 */
boolean DetermineActiveBackends()
{ if( ! ExecuteBashCommand( determine_active_scanner_backends_commandline ) )
  { Report::Error( // Message of a Report::Error.
                   // Only a simple message because this error does not happen on a normal system
                   // (i.e. a system which is not totally broken or totally messed up).
                   // Do not confuse this error with the case when no active driver was determined.
                   // The latter results no error.
                   _("Failed to determine the active drivers.")
                 );
    return false;
  }
  if( -1 == SCR::Read( .target.size, active_backends_filename ) )
  { y2milestone( "Error: %1: file does not exist.", active_backends_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("File %1 does not exist."),
                            active_backends_filename
                          )
                 );
    return false;
  }
  active_backends = (list< string >)SCR::Read( .target.ycp, active_backends_filename );
  if( nil == active_backends )
  { y2milestone( "Error: Failed to read %1", active_backends_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("Failed to read %1."),
                            active_backends_filename
                          )
                 );
    active_backends = [];
    return false;
  }
  y2milestone( "Active backends: %1", active_backends );
  return true;
}

/**
 * Try to autodetect USB and SCSI scanners and HP all-in-one USB and NETWORK scanners
 * by calling a bash script which calls "sane-find-scanner"
 * and (if available) "hp-probe" and processes its output
 * and stores the results as YCP list in a temporary file
 * and then read the temporary file (SCR::Read)
 * to get the YCP list of @ref autodetected_scanner_map
 * @return true on success
 */
boolean AutodetectScanners()
{ if( ! ExecuteBashCommand( autodetect_scanners_commandline ) )
  { Report::Error( // Message of a Report::Error.
                   // Only a simple message because this error does not happen on a normal system
                   // (i.e. a system which is not totally broken or totally messed up).
                   // Do not confuse this error with the case when no scanner was autodetected.
                   // The latter results no error.
                   _("Failed to detect scanners automatically.")
                 );
    return false;
  }
  if( -1 == SCR::Read( .target.size, autodetected_scanners_filename ) )
  { y2milestone( "Error: %1: file does not exist.", autodetected_scanners_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("File %1 does not exist."),
                            autodetected_scanners_filename
                          )
                 );
    return false;
  }
  autodetected_scanners = (list< map< string, string > >)SCR::Read( .target.ycp, autodetected_scanners_filename );
  if( nil == autodetected_scanners )
  { y2milestone( "Error: Failed to read %1", autodetected_scanners_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("Failed to read %1."),
                            autodetected_scanners_filename
                          )
                 );
    autodetected_scanners = [];
    return false;
  }
  if( ignore_unknown_USB_scanners )
  { // Entries in autodetected_scanners are skipped in OverviewContents() if the description is empty.
    // Therefore for unknown USB scanners the description is set to the empty string.
    integer autodetected_scanners_index = -1;
    foreach( map< string, string > autodetected_scanner,
             autodetected_scanners,
             { // Set the autodetected_scanners_index to the index number
               // of the actual autodetected_scanner in autodetected_scanners:
               autodetected_scanners_index = autodetected_scanners_index + 1;
               // Use local variables to have shorter variable names:
               string usb_vendor_id = autodetected_scanner["usb_vendor_id"]:"";
               string usb_product_id = autodetected_scanner["usb_product_id"]:"";
               if( "" != usb_vendor_id && "" != usb_product_id )
               { string usb_id =  UnifyHexString( usb_vendor_id ) + ":" + UnifyHexString( usb_product_id );
                 if( ! contains( database_usbids, usb_id ) )
                 { autodetected_scanners[autodetected_scanners_index,"description"] = "";
                   y2milestone( "No USB ID in database for %1", autodetected_scanner );
                 }
               }
             }
           );
  }
  y2milestone( "Autodetected scanners: %1", autodetected_scanners );
  return true;
}

/**
 * Test and set scanner access permissions for USB scanners and SCSI scanners
 * for resmgr via HAL by calling a bash script which does all the work.
 * @return true on success
 */
boolean SetScannerAccessPermissions()
{ // Build the command line parameter:
  string sane_devices = "";
  foreach( map< string, string > active_scanner,
           active_scanners,
           { sane_devices = sane_devices + active_scanner["sane_device"]:"unknown" + ";";
           }
         );
  // Execute the command line:
  if( ! ExecuteBashCommand( test_and_set_scanner_access_permissions_commandline
                            + " '"
                            + sane_devices
                            + "'"
                          )
    )
  { return false;
  }
  return true;
}

/**
 * Test whether there exist a print queue which depends on the specified SANE backend.
 * Examples:
 * hpaio (package hplip):
 * Setting up the hpaio backend activates also the hplip service.
 * It may happen that the conflicting service ptal is in use by the CUPS printing system.
 * I.e. there may be a print queue which uses the ptal CUPS backend.
 * hpoj (package hp-officeJet):
 * Setting up the hpoj backend requires to initialize/activate/start the ptal service.
 * It may happen that the conflicting service hplip is in use.
 * I.e. there may be a print queue which uses the hp CUPS backend.
 * Note:
 * The test is only implememnted for the CUPS printing system.
 * A dependant print queue can exists only for the SANE backends hpaio and hpoj.
 * For all other backends no dependant print queue can exists.
 * @param backend_name string of the SANE backend name
 * @return true if a dependant CUPS print queue exists for the backends hpaio or hpoj
 */
boolean DependantPrintQueueExists( string backend_name )
{ // Examples of a "/usr/bin/lpstat -v" output when the hp CUPS backend is used:
  //   device for Queue1: hp:/usb/DeskJet_990C?serial=MX09R1T14QLH
  //   device for Queue2: hp:/net/Officejet_7200_series?ip=10.10.100.100
  // Example of a "/usr/bin/lpstat -v" output when the hpfax CUPS backend is used:
  //   device for Queue3: hpfax:/net/Officejet_7200_series?ip=10.10.100.100
  // Examples of a "/usr/bin/lpstat -v" output when the ptal CUPS backend is used:
  //   device for Queue4: ptal:/mlc:par:HP_LaserJet_1220
  //   device for Queue5: ptal:/mlc:usb:HP_LaserJet_1220
  // If /usr/bin/lpstat (from the package cups-client) is not installed
  // or if it is not from CUPS (e.g. from LPRng or from a third-party printing system)
  // and doesn't support the -v parameter or results a different output
  // then it returns "false" which is perfectly o.k. because then
  // there is no CUPS printing system installed (because cups requires cups-client)
  // and then no print queue exists which uses a CUPS backend.
  // Note that therefore it is not detected when the hplip service or the ptal service
  // is required by a print queue for LPRng or for a third-party printing system.
  if( "hpaio" == backend_name )
  { return ExecuteBashCommand( "/usr/bin/lpstat -v | /bin/egrep -q ': hp:/|: hpfax:/'" );
  }
  if( "hpoj" == backend_name )
  { return ExecuteBashCommand( "/usr/bin/lpstat -v | /bin/grep -q ': ptal:/'" );
  }
  // Fallback to false i.e. assume that there is no conflicting print queue:
  return false;
}

/*
 * Global functions:
 */

/**
 * Read all scanner settings:
 * - Check installed packages
 * - Read or create the scanner database
 * - Determine active scanners
 * - Determine active backends
 * - Try to autodetect USB and SCSI scanners and HP all-in-one USB and NETWORK scanners
 * @return true on success
 */
global boolean Read()
{ // Define the progress stages:
  Progress::New( // Header of a Progress::New:
                 _("Initializing Scanner Configuration"),
                 " ",
                 5,
                 [ // 1. progress stage name of a Progress::New:
                   _("Check installed packages"),
                   // 2. progress stage name of a Progress::New:
                   _("Read or create the scanner database"),
                   // 3. progress stage name of a Progress::New:
                   _("Determine active scanners"),
                   // 4. progress stage name of a Progress::New:
                   _("Determine active drivers"),
                   // 5. progress stage name of a Progress::New:
                   _("Detect scanners")
                 ],
                 [ // 1. progress step progress bar title of a Progress::New:
                   _("Checking installed packages..."),
                   // 2. progress step progress bar title of a Progress::New:
                   _("Reading or creating the scanner database..."),
                   // 3. progress step progress bar title of a Progress::New:
                   _("Determining active scanners..."),
                   // 4. progress step progress bar title of a Progress::New:
                   _("Determining active drivers..."),
                   // 5. progress step progress bar title of a Progress::New:
                   _("Detecting scanners..."),
                   // Last progress step progress bar title of a Progress::New:
                   _("Finished")
                 ],
                 ""
               );
  // Progress 1. stage (Check installed packages):
  if( Abort() ) return false;
  Progress::NextStage();
  // Make sure the package sane is installed (otherwise abort):
  if( ! TestAndInstallPackage( "sane-backends" ) )
  { return false;
  }
  // Check installed package version of sane-backends, hplip, iscan, iscan-free:
  actual_environment["sane-backends_version"] = InstalledPackageVersion( "sane-backends" );
  actual_environment["hplip_version"] = InstalledPackageVersion( "hplip" );
  actual_environment["iscan_version"] = InstalledPackageVersion( "iscan" );
  actual_environment["iscan-free_version"] = InstalledPackageVersion( "iscan-free" );
  y2milestone( "Version of sane-backends, hplip, iscan, iscan-free: %1, %2, %3, %4",
               actual_environment["sane-backends_version"]:"failed",
               actual_environment["hplip_version"]:"failed",
               actual_environment["iscan_version"]:"failed",
               actual_environment["iscan-free_version"]:"failed"
             );
  // Read stored environment:
  if( -1 != SCR::Read( .target.size, environment_filename ) )
  { stored_environment = (map< string, string >)SCR::Read( .target.ycp, environment_filename );
    if( stored_environment == nil )
    { y2milestone( "Warning: Failed to read the stored environment." );
      stored_environment = $[ "sane-backends_version":"failed to read",
                              "hplip_version":"failed to read",
                              "iscan_version":"failed to read",
                              "iscan-free_version":"failed to read"
                            ];
    }
  }
  // Progress 2. stage (Read or create the scanner database):
  if( Abort() ) return false;
  Progress::NextStage();
  if( actual_environment["sane-backends_version"]:"0" != stored_environment["sane-backends_version"]:"1"
      || actual_environment["hplip_version"]:"0" != stored_environment["hplip_version"]:"1"
      || actual_environment["iscan_version"]:"0" != stored_environment["iscan_version"]:"1"
      || actual_environment["iscan-free_version"]:"0" != stored_environment["iscan-free_version"]:"1"
      || -1 == SCR::Read( .target.size, database_filename )
    )
  { // Show feedback because creating the scanner database takes a few seconds:
    Popup::ShowFeedback( // No title for a simple busy message:
                         "",
                         // Busy message:
                         // Body of a Popup::ShowFeedback:
                         _("Creating scanner database...")
                       );
    if( ! ExecuteBashCommand( create_database_commandline ) )
    { Popup::ClearFeedback();
      Report::Error( // Message of a Report::Error.
                     // Only a simple message because this error does not happen on a normal system
                     // (i.e. a system which is not totally broken or totally messed up).
                     _("Aborting: Failed to create the scanner database.")
                   );
      return false;
    }
    Popup::ClearFeedback();
  }
  database = (list< map< string, string > >)SCR::Read( .target.ycp, database_filename );
  if( database == nil )
  { y2milestone( "Aborting: Failed to read %1", database_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("Aborting: Failed to read %1."),
                            database_filename
                          )
                 );
    return false;
  }
  // Extract a (sorted) list of unique manufacturer names and
  // another list of known USB scanner USB vendor and product IDs
  // from the scanner database.
  // The latter makes sense because it is needed in AutodetectScanners
  // because ignore_unknown_USB_scanners is set to true by default.
  string usbid = "";
  list< string > ids = [];
  foreach( map< string, string > database_entry,
           database,
           { database_manufacturers = add( database_manufacturers, database_entry["manufacturer"]:"unknown" );
             usbid = tolower( database_entry["usbid"]:"" );
             if( regexpmatch( usbid, "0x[0-9a-f]+:0x[0-9a-f]+" ) )
             { ids = splitstring( usbid, ":" );
               database_usbids = add( database_usbids, UnifyHexString( ids[0]:"" ) + ":" + UnifyHexString( ids[1]:"" ) );
             }
           }
         );
  database_manufacturers = toset( database_manufacturers );
  database_usbids = toset( database_usbids );
  // Progress 3. stage (Determine active scanners):
  if( Abort() ) return false;
  Progress::NextStage();
  if( ! DetermineActiveScanners() )
  { active_scanners = [];
  }
  // Progress 4. stage (Determine active drivers):
  if( Abort() ) return false;
  Progress::NextStage();
  if( ! DetermineActiveBackends() )
  { active_backends = [];
  }
  // Progress 5. stage (Detect scanners):
  if( Abort() ) return false;
  Progress::NextStage();
  if( ! AutodetectScanners() )
  { autodetected_scanners = [];
  }
  else
  { // An ugly workaround for a strange problem (Suse/Novell Bugzilla bug #75709):
    // Sometimes AutodetectScanners (i.e. "sane-find-scanner") doesn't detect a scanner
    // but usually it works well for a second attempt when it is run a bit later.
    // At the moment the exact reason is unknown.
    // Therefore AutodetectScanners is simply called a second time (after waiting a bit)
    // if it ran without errors but didn't detect a scanner on the first run.
    // At least one sane-find-scanner output description string must exist
    // if sane-find-scanner had detected a scanner:
    if( "no description" == autodetected_scanners[0,"description"]:"no description" )
    { y2milestone( "No autodetected scanners on the first run. To be safe wait a bit and then run AutodetectScanners a second time." );
      // Show feedback because it takes a few seconds:
      Popup::ShowFeedback( // No title for a simple busy message:
                           "",
                           // Busy message:
                           // Body of a Popup::ShowFeedback:
                           _("Detecting scanners...")
                         );
      // Wait 10 seconds:
      sleep( 10000 );
      Popup::ClearFeedback();
      if( ! AutodetectScanners() )
      { autodetected_scanners = [];
      }
    }
  }
  // Progress last stage (progress finished):
  if( Abort() ) return false;
  Progress::Finish();
  // Sleep one second to let the user notice that the progress has finished:
  sleep( 1000 );
  if( Abort() ) return false;
  return true;
}

/**
 * Write scanner settings:
 * - Save the actual environment
 * @return true on success
 */
global boolean Write()
{ // Define the progress stages:
  Progress::New( // Header of a Progress::New:
                 _("Writing Scanner Configuration"),
                 " ",
                 1,
                 [ // 1. progress stage name of a Progress::New:
                   _("Save the actual environment")
                 ],
                 [ // 1. progress step progress bar title of a Progress::New:
                   _("Saving the actual environment..."),
                   // Last progress step progress bar title of a Progress::New:
                   _("Finished")
                 ],
                 ""
               );
  // Progress first stage (Save the actual environment):
  if( Abort() ) return false;
  Progress::NextStage();
  if( ! SCR::Write( .target.ycp, environment_filename, actual_environment ) )
  { y2milestone( "Warning: Failed to save the actual environment." );
  }
  // Progress last stage (progress finished):
  if( Abort() ) return false;
  Progress::Finish();
  // Sleep one second to let the user notice that the progress has finished:
  sleep( 1000 );
  if( Abort() ) return false;
  return true;
}

/**
 * Restart the whole autodetection by calling all autodetection functions
 * in the same order as during the initial Read():
 * DetermineActiveScanners results a new active_scanners map
 * which is empty if nothing was detected or if DetermineActiveScanners fails.
 * DetermineActiveBackends results a new active_backends list
 * which is empty if nothing was detected or if DetermineActiveBackends fails.
 * AutodetectScanners results a new autodetected_scanners map
 * which is empty if nothing was detected or if AutodetectScanners fails.
 * RestartDetection is called when the user restarts the detection in the OverviewDialog
 * and if testing of an active scanner failed (see the TestBackend function).
 * The result is that all information in the OverviewDialog is recreated.
 * @return true in any case (errors result only empty maps or list).
 */
global boolean RestartDetection()
{ Popup::ShowFeedback( // No title for a simple busy message:
                       "",
                       // Busy message:
                       // Body of a Popup::ShowFeedback:
                       _("Detecting scanners...")
                     );
  if( ! DetermineActiveScanners() )
  { active_scanners = [];
  }
  if( ! DetermineActiveBackends() )
  { active_backends = [];
  }
  if( ! AutodetectScanners() )
  { autodetected_scanners = [];
  }
  Popup::ClearFeedback();
  return true;
}

/**
 * Run hp-setup:
 * @return false if hp-setup cannot be run and return true in any other case
 * because there is no usable exit code of hp-setup (always zero even in case of error).
 */
global boolean RunHpsetup()
{ // First of all the multi-line strings because such strings cannot be indented:
  string ptal_in_use_conflict_message =
  // Message of a Report::Error when hp-setup should be run.
  // Do not change or translate "ptal", it is a service name.
  // Do not change or translate "hp-setup", it is a program name.
  // Do not change or translate "HPLIP", it is a subsystem name.
_("There is at least one printer configuration that uses the ptal service.
It is possible to proceed but then the running ptal service could prevent
that hp-setup works correctly.
It is recommended to abort the scanner configuration now,
stop the ptal service, change the printer configuration to use HPLIP,
and start the scanner configuration again afterwards.
");
  string displaytest_failed_message =
  // Message of a Report::Error when hp-setup should be run.
  // Do not change or translate "hp-setup", it is a program name:
_("Cannot run hp-setup because no graphical display can be opened.
This happens in particular when YaST runs in text-only mode,
or when the user who runs YaST has no DISPLAY environment variable set,
or when the YaST process is not allowed to access the graphical display.
In this case you should abort the scanner configuration now,
run hp-setup manually, and start the scanner configuration again afterwards.
");
  string install_hplip_message =
  // Message of a Popup::YesNo when hplip should be installed.
  // Do not change or translate "hp-setup", it is a program name.
  // Do not change or translate "hplip", it is a package name:
_("It seems hplip is not installed which is required to run hp-setup.
Should the hplip package be installed?
");
  string hpsetup_not_executable_message =
  // Message of a Report::Error when hp-setup should be run.
  // Do not change or translate "hp-setup", it is a program name:
_("Cannot run hp-setup because
/usr/bin/hp-setup is not executable
or does not exist.
");
  string hpsetup_busy_message =
  // Body of a Popup::ShowFeedback.
  // Do not change or translate "hp-setup", it is a program name:
_("Launched hp-setup.
You must finish hp-setup before you can proceed with the scanner configuration.
");
  if( DependantPrintQueueExists( "hpoj" ) )
  { y2milestone( "Error: hp-setup is not launched because of conflict: PTAL is in use by a CUPS queue." );
    Report::Error( ptal_in_use_conflict_message );
    return false;
  }
  if( ! ExecuteBashCommand( "/usr/lib/YaST2/bin/displaytest" ) )
  { // The file location is the same on i386, x86_64, ppc, ppc64, and ia64 (nowhere "lib64" or "lib32").
    // In particular when YaST runs in text-only mode, hp-setup must not be launched
    // because it would run without any contact to the user "in the background"
    // while in the foreground YaST waits for hp-setup to be finished
    // which is imposible for the user so that the result is a deadlock.
    // All the user could do is to kill the hp-setup process.
    // It does not matter if displaytest fails orderly because XOpenDisplay fails
    // or if it crashes because of missing libX11.so on a minimal installation without X
    // because any non-zero exit code indicates that no graphical window can be opened.
    // Therefore the yast2-scanner RPM should not require a full installed X system.
    // Nevertheless the RPM build AutoReqProv creates a requirement for libX11.so
    // so that a few xorg-x11-lib* packages (xorg-x11-libX11, xorg-x11-libxcb, xorg-x11-libXau)
    // are enforced by RPM to be installed.
    y2milestone( "Error: hp-setup is not launched because /usr/lib/YaST2/bin/displaytest failed." );
    Report::Error( displaytest_failed_message );
    return false;
  }
  if( "not installed" == actual_environment["hplip_version"]:"not installed"
      || "failed to determine" == actual_environment["hplip_version"]:"failed to determine"
    )
  { y2milestone( "hplip not installed or failed to determine its version. Therefore testing and installing hplip." );
    if( ! Popup::YesNo( install_hplip_message ) )
    { y2milestone( "Error: hp-setup cannot run because user rejected to install hplip." );
      return false;
    }
    if( ! TestAndInstallPackage( "hplip" ) )
    { y2milestone( "Error: hp-setup cannot run because YaST failed to install hplip." );
      return false;
    }
  }
  if( ! ExecuteBashCommand( "test -x /usr/bin/hp-setup" ) )
  { y2milestone( "Error: /usr/bin/hp-setup not executable or does not exist." );
    Report::Error( hpsetup_not_executable_message );
    return false;
  }
  Popup::ShowFeedback( // No title for a simple busy message:
                       "",
                       // Busy message:
                       hpsetup_busy_message
                     );
  ExecuteBashCommand( "/usr/bin/hp-setup" );
  Popup::ClearFeedback();
  return true;
}

/**
 * Create the content for WizardHW::SetContents
 * @return a list of maps with keys
 * "id" : string = the identification of the device,
 * "rich_descr" : string = RichText description of the device
 * "table_descr" : list<string> = fields of the table
 */
global list< map< string, any > > OverviewContents()
{ list< map< string, any > > overview_contents = [];
  // The id_prefix can be one of the following:
  // "autodetected_scanner:", "active_scanner:", "active_backend:", "nothing".
  // An index number will be appended to the id_prefix except when it is "nothing"
  // which results an unique id for each overview_content entry.
  // Therefore the id can be one of the following:
  // "autodetected_scanner:[0-9]*" where [0-9]* is the autodetected_scanners_index
  // (i.e. the index in the autodetected_scanners list to which the overview_content entry matches)
  // "active_scanner:[0-9]*" where [0-9]* is the active_scanners_index
  // (i.e. the index in the active_scanners list to which the overview_content entry matches)
  // "active_backend:[0-9]*" where [0-9]* is the active_backends_index
  // (i.e. the index in the active_backends list to which the overview_content entry matches)
  // "nothing" which is used as fallback only if none of the above was set
  // (i.e. if neither a scanner was autodetected nor an active scanner nor an active backend exists)
  string id_prefix = "";
  // On top of the table list the autodetected but not yet configured scanners
  // i.e. those scanners which are in autodetected_scanners but not in active_scanners
  // except remote active scanners which are accessed via the "net" meta-backend:
  id_prefix = "autodetected_scanner:";
  // Process the autodetected_scanners list:
  integer autodetected_scanners_index = -1;
  foreach( map< string, string > autodetected_scanner,
           autodetected_scanners,
           { // Set the autodetected_scanners_index to the index number
             // of the actual autodetected_scanner in autodetected_scanners:
             autodetected_scanners_index = autodetected_scanners_index + 1;
             // Use local variables to have shorter variable names:
             string manufacturer = autodetected_scanner["manufacturer"]:"";
             string model = autodetected_scanner["model"]:"";
             string description = autodetected_scanner["description"]:"";
             string device = autodetected_scanner["device"]:"";
             // The last entry in the autodetected_scanners list is an empty map.
             // Skip at least this last entry:
             if( "" != description )
             { // Test whether the autodetected_scanner is one of the active_scanners
               // except remote active scanners which are accessed via the "net" meta-backend.
               // For HP all-in-one devices the device entry is empty
               // (therefore the test for non-empty device before the substring test)
               // but here the model entry is a substring of the sane_device, for example
               // "HP LaserJet 1220" in "hpaio:/usb/HP_LaserJet_1220?serial=00XXXXXXXXXX"
               // "Officejet 7200 series" in "hpaio:/net/Officejet_7200_series?ip=10.10.100.100"
               // which shows that it is crucial to unify both strings before the substring test.
               // Even if there are two "HP_LaserJet_1220" connected to the USB
               // or two "Officejet_7200_series" with different IP addresses,
               // this should work correctly because once the hpaio driver is activated
               // it recognizes all HP all-in-one devices which have a CUPS queue
               // but only those are autodetected, see the autodetect_scanners script.
               // If an autodetected_scanner is one of the active_scanners,
               // there is no need to set it up again
               // and then don't show it in the list of detected_scanners:
               boolean show_as_detected_scanner = true;
               foreach( map< string, string > active_scanner,
                        active_scanners,
                        { string backend = active_scanner["backend"]:"";
                          string sane_device = active_scanner["sane_device"]:"unknown";
                          if( "net" != backend )
                          { if( ( "hpaio" != backend
                                  && "" != device
                                  && issubstring( sane_device, device )
                                )
                                || ( "hpaio" == backend
                                     && "" != model
                                     && issubstring( filterchars( tolower( sane_device ), alnum_chars ),
                                                     filterchars( tolower( model ), alnum_chars )
                                                   )
                                   )
                              )
                            { show_as_detected_scanner = false;
                            }
                          }
                        }
                      );
               if( show_as_detected_scanner )
               { string id = id_prefix + tostring( autodetected_scanners_index );
                 string rich_descr = "";
                 string model_string = "";
                 // Avoid that the manufacturer name is shown duplicated
                 // when the autodetected manufacturer name
                 // is also a part of the autodetected model name.
                 // E.g.: "EPSON" "Epson Perfection 123"
                 // Use a simple case insensitive substring test and ignore false positives
                 // (e.g.: "HP" "High Performance Scanner HPS 1234")
                 // because it is sufficient to show only the model name
                 // because different manufacturers use different model names.
                 if( "" != manufacturer
                     && ! issubstring( tolower( model ), tolower( manufacturer ) )
                   )
                 { model_string = manufacturer + " ";
                 }
                 if( "" != model )
                 { model_string = model_string + model + " ";
                 }
                 model_string = model_string + description;
                 list< string > table_descr = [ // A prefix for the first column of a table
                                                // where autodetected scanners are listed in the second column
                                                // to denote those scanners which are not configured yet:
                                                _("Not Configured:"),
                                                model_string
                                              ];
                 map <string, any> overview_content = $[ "id": id,
                                                         "rich_descr": rich_descr,
                                                         "table_descr": table_descr
                                                       ];
                 overview_contents = add( overview_contents , overview_content );
               }
             }
           }
         );
  // In the middle of the table list the active scanners
  // i.e. those scanners which are in active_scanners:
  id_prefix = "active_scanner:";
  // Process the autodetected_scanners list:
  integer active_scanners_index = -1;
  foreach( map< string, string > active_scanner,
           active_scanners,
           { // Set the active_scanners_index to the index number
             // of the actual active_scanner in active_scanners:
             active_scanners_index = active_scanners_index + 1;
             // Use local variables to have shorter variable names:
             string backend = active_scanner["backend"]:"";
             // Fallback device name if the real device name is missing:
             string sane_device = active_scanner["sane_device"]:_("Unknown device");
             // Fallback manufacturer name if the real manufacturer name is missing:
             string manufacturer = active_scanner["manufacturer"]:_("Unknown manufacturer");
             // Fallback model name if the real model name is missing:
             string model = active_scanner["model"]:_("Unknown model");
             // Avoid that the manufacturer name is shown duplicated
             // when the autodetected manufacturer name
             // is also a part of the autodetected model name.
             // E.g.: "EPSON" "Epson Perfection 123"
             // Use a simple case insensitive substring test and ignore false positives
             // (e.g.: "HP" "High Performance Scanner HPS 1234")
             // because it is sufficient to show only the model name
             // because different manufacturers use different model names.
             if( issubstring( tolower( model ), tolower( manufacturer ) ) )
             { manufacturer = "";
             }
             // The last entry in the active_scanners list is an empty map.
             // Skip at least this last entry:
             if( "" != backend )
             { string id = id_prefix + tostring( active_scanners_index );
               string rich_descr = "";
               string active_scanner_text = sformat( // Active scanner entry where
                                                     // %1 will be replaced by the manufacturer name
                                                     // %2 will be replaced by the model name
                                                     // %3 will be replaced by the device name
                                                     // where the scanner is connected to:
                                                     _("%1 %2 at %3"),
                                                     manufacturer,
                                                     model,
                                                     sane_device
                                                   );
               list< string > table_descr = [ backend,
                                              active_scanner_text
                                            ];
               map <string, any> overview_content = $[ "id": id,
                                                       "rich_descr": rich_descr,
                                                       "table_descr": table_descr
                                                     ];
               overview_contents = add( overview_contents , overview_content );
             }
           }
         );
  // At the bottom of the table list the active backends without an active scanner
  // i.e. those backends which are in active_backends but not in active_scanners:
  id_prefix = "active_backend:";
  // Process the active_backends list:
  integer active_backends_index = -1;
  foreach( string active_backend,
           active_backends,
           { // Set the active_backends_index to the index number
             // of the actual active_backend in active_backends:
             active_backends_index = active_backends_index + 1;
             // The last entry in the active_backends list is an empty string.
             // Skip this last entry:
             if( "" != active_backend )
             { // Test whether the active_backend is one of the active_scanners.
               // If yes, then there is no need to show it again:
               boolean show_as_active_backend = true;
               foreach( map< string, string > active_scanner,
                        active_scanners,
                        { if( active_backend == active_scanner["backend"]:"unknown" )
                          { show_as_active_backend = false;
                          }
                        }
                      );
               if( show_as_active_backend )
               { string id = id_prefix + tostring( active_backends_index );
                 string rich_descr = "";
                 list< string > table_descr = [ active_backend,
                                                // A suffix for the second column of a table
                                                // where active scanner drivers are listed in the first column
                                                // to denote those drivers for which there is no matching active scanner:
                                                _("No scanner recognized by this driver")
                                              ];
                 map <string, any> overview_content = $[ "id": id,
                                                         "rich_descr": rich_descr,
                                                         "table_descr": table_descr
                                                       ];
                 overview_contents = add( overview_contents , overview_content );
               }
             }
           }
         );
  // If the overview_contents list is still empty, set a fallback
  // so that there is no empty table shown to the user:
  if( size( overview_contents ) < 1 )
  { list< string > table_descr = [ "",
                                   // A fallback list entry so that there is no empty list shown to the user
                                   // when neither a scanner was autodetected
                                   // nor an active scanner was found
                                   // nor an active driver was found:
                                   _("No scanner was detected and no active scanner or driver exists.")
                                 ];
    overview_contents = [ $[ "id": "nothing",
                             "rich_descr": "",
                             "table_descr": table_descr
                           ]
                        ];
  }
  // Return the overview_contents list:
  y2milestone( "Overview contents: %1", overview_contents );
  return overview_contents;
}

/**
 * Create a list of items from the database entries
 * which is used for the SelectionBox in the SelectModelDialog
 * @param filter_string string of a search string to return only matching models
 *        (retunr all models if filter_string is the empty string)
 * @return list of model strings (manufacturer, model, backend, comment)
 */
global list ModelItems( string filter_string )
{ // Make a list of the scanner models according to the database
  // and take the filter_string into account (if it is not the empty string)
  // and try to preselect a model according to a selected autodetected scanner:
  integer database_index = -1;
  string model_string = "";
  string interface_and_usbid_string = "";
  string status_string = "";
  // Scanner model list firmware entry for models which require a firmware upload:
  string firmware_string = _("Firmware upload required.");
  list< term > model_items = [];
  foreach( map< string, string > database_entry,
           database,
           { // Set the database_index to the index number of the current database_entry:
             database_index = database_index + 1;
             // Use local variables to have shorter variable names:
             string manufacturer = database_entry["manufacturer"]:"unknown manufacturer";
             string model = database_entry["model"]:"unknown model";
             string backend = database_entry["backend"]:"unknown";
             string package = database_entry["package"]:"unknown";
             string status = database_entry["status"]:"unknown";
             string interface = database_entry["interface"]:"";
             string usbid = database_entry["usbid"]:"";
             string comment = database_entry["comment"]:"";
             string firmware = database_entry["firmware"]:"unknown";
             // Build the model_string:
             if( manufacturer != "unknown manufacturer"
                 && model != "unknown model"
                 && backend != "unknown"
                 && package != "unknown"
                 && status != "unknown"
               )
             { // Build the interface_and_usbid_string:
               // Enclose it in parenthesis to seperate it from the rest of the model_string
               // because the interface_and_usbid_string is untranslatable stuff like
               // the acronyms "SCSI" and/or "USB or the hexadecimal numbers of the USB-ID:
               if( issubstring( tolower( interface ), "scsi" ) )
               { // The scanner has SCSI:
                 if( usbid != "" )
                 { // The scanner has SCSI and a USB-ID is known:
                   interface_and_usbid_string = "(SCSI, USB-ID " + usbid + ")";
                 }
                 else
                 { // The scanner has SCSI but no USB-ID is known:
                   if( issubstring( tolower( interface ), "usb" ) )
                   { // The scanner has SCSI and USB:
                     interface_and_usbid_string = "(SCSI, USB)";
                   }
                   else
                   { // The scanner has SCSI but no USB:
                     interface_and_usbid_string = "(SCSI)";
                   }
                 }
               }
               else
               { // The scanner has no SCSI:
                 if( usbid != "" )
                 { // The scanner has USB because a USB-ID is known:
                   interface_and_usbid_string = "(USB-ID " + usbid + ")";
                 }
                 else
                 { // No USB-ID is known:
                   if( issubstring( tolower( interface ), "usb" ) )
                   { // The scanner has USB:
                     interface_and_usbid_string = "(USB)";
                   }
                   else
                   { // The scanner has neither SCSI nor USB:
                     interface_and_usbid_string = "";
                   }
                 }
               }
               // Enclose a comment in brackets to seperate it from the rest of the model_string
               // because the comment is untranslatable English text from the *desc files:
               if( "" != comment )
               { comment = "[" + comment + "]";
               }
               // Build a translatable status_string:
               // These are the exiting status values according to the *desc files in sane-1.0.15 (9.3)
               // and how often each value apppears:
               //   "good"        (452)
               //   "unsupported" (257)
               //   "complete"    (227)
               //   "untested"    (151)
               //   "basic"       (66)
               //   "minimal"     (14)
               // Enclose the backend name and the package name in single quotes to seperate them
               // from the rest of the model_string because they are untranslatable English words.
               if( "good" == status )
               { status_string = sformat( // Scanner model list status entry for "good" supported models:
                                          // %1 will be replaced by the backend (scanner driver) name
                                          // %2 will be replaced by the package name which provides the backend
                                          _("Driver %1 (package %2) provides good functionality."),
                                          backend,
                                          package
                                        );
               }
               else
               { if( "unsupported" == status )
                 { if( "unsupported" == backend )
                   { // Scanner model list status entry for unsupported models
                     status_string = _("This scanner is not supported.");
                   }
                   else
                   { status_string = sformat( // Scanner model list status entry for models
                                              // which are listed as "unsupported" for a particular driver:
                                              // %1 will be replaced by the backend (scanner driver) name
                                              // %2 will be replaced by the package name which provides the backend
                                              _("This scanner is not supported by the driver %1 (package %2)."),
                                              backend,
                                              package
                                            );
                   }
                 }
                 else
                 { if( "complete" == status )
                   { status_string = sformat( // Scanner model list status entry for "complete" supported models:
                                              // %1 will be replaced by the backend (scanner driver) name
                                              // %2 will be replaced by the package name which provides the backend
                                              _("Driver %1 (package %2) provides complete functionality."),
                                              backend,
                                              package
                                            );
                   }
                   else
                   { if( "untested" == status )
                     { status_string = sformat( // Scanner model list status entry for "untested" models:
                                                // %1 will be replaced by the backend (scanner driver) name
                                                // %2 will be replaced by the package name which provides the backend
                                                _("Driver %1 (package %2) may work, but was not tested."),
                                                backend,
                                                package
                                              );
                     }
                     else
                     { if( "basic" == status )
                       { status_string = sformat( // Scanner model list status entry for "basic" supported models:
                                                  // %1 will be replaced by the backend (scanner driver) name
                                                  // %2 will be replaced by the package name which provides the backend
                                                  _("Driver %1 (package %2) provides basic functionality."),
                                                  backend,
                                                  package
                                                );
                       }
                       else
                       { if( "minimal" == status )
                         { status_string = sformat( // Scanner model list status entry for "minimal" supported models:
                                                    // %1 will be replaced by the backend (scanner driver) name
                                                    // %2 will be replaced by the package name which provides the backend
                                                    _("Driver %1 (package %2) provides minimal functionality."),
                                                    backend,
                                                    package
                                                  );
                         }
                         else
                         { status_string = sformat( // Fallback scanner model list status entry for models
                                                    // which are listed but without a known support status:
                                                    // %1 will be replaced by the backend (scanner driver) name
                                                    // %2 will be replaced by the package name which provides the backend
                                                    _("Driver %1 (package %2) may work, but the functionality is unknown."),
                                                    backend,
                                                    package
                                                  );
                         }
                       }
                     }
                   }
                 }
               }
               if( "required" == firmware )
               { // The model_string for supported models which require a firmware upload:
                 model_string = sformat( "%1 %2 : %3 %4 %5 %6",
                                         manufacturer,
                                         model,
                                         firmware_string,
                                         status_string,
                                         interface_and_usbid_string,
                                         comment
                                       );
               }
               else
               { // The model_string for all other supported and unsupported models:
                 model_string = sformat( "%1 %2 : %3 %4 %5",
                                         manufacturer,
                                         model,
                                         status_string,
                                         interface_and_usbid_string,
                                         comment
                                       );
               }
               // If there is an autodetected USB scanner selected,
               // test whether an USB-ID in the database matches to the selected autodetected scanner
               // and select it in the model_items list if it is at least "good supported"
               // where "good supported" means that the support status is "complete" or "good"
               // and there is no special (manual) setup for firmware upload required
               // (automated firmware upload as e.g. "epkowa" does is "good").
               // Do not select a model if it is less than "good supported" to avoid that
               // there is another driver entry in the database which has no USB-ID
               // but which provides much better support (e.g. the model entry with USB-ID
               // provides minimal support but an entry without USB-ID provides good support)
               // and to avoid that the user clicks too fast [Next] without having a look
               // what there was selected (e.g. ignoring any comment regarding the model).
               // If more than one model in the database matches, select those model
               // with the better support status (complete > good).
               // It even the support status are the same, select those model with the driver
               // which is considered better regarding how well the scanner is supported
               // (e.g.: hpaio > any other driver in particular hpaio is better than outdated hpoj)
               // regardless whether or not the driver is free software (epkowa > any other driver).
               // If no model matches then leave the selected_model_database_index unchanged
               // to select an already selected model in the model_items list again.
               // This happens for example when going 'back' to the model selection screen.
               if( selected_autodetected_scanners_index >= 0 )
               { string autodetected_usbid = autodetected_scanners[selected_autodetected_scanners_index,"usb_vendor_id"]:""
                                             + ":"
                                             + autodetected_scanners[selected_autodetected_scanners_index,"usb_product_id"]:"";
                 // There is no false match when one or both USB-IDs are missing
                 // because autodetected_usbid is not the empty string but at least ":"
                 // and usbid is either a complete "0x0a1b:0x2c3d" USB-ID or the empty string:
                 if( autodetected_usbid == usbid
                     && firmware != "required"
                     && ( status == "complete"
                          || status == "good"
                        )
                   )
                 { if( -1 == selected_model_database_index )
                   { // There is no model selected.
                     // Select the current model:
                     selected_model_database_index = database_index;
                     y2milestone( "Selected model: %1", model_string );
                   }
                   else
                   { // There is already a model selected.
                     // Test which has the better support status:
                     string selected_status = database[selected_model_database_index,"status"]:"unknown";
                     if( status != selected_status )
                     { if( "complete" == status )
                       { // Select the current model:
                         selected_model_database_index = database_index;
                         y2milestone( "Selected other model: %1", model_string );
                       }
                     }
                     else
                     { // The support status are the same.
                       // Test which has the better driver:
                       string selected_backend = database[selected_model_database_index,"backend"]:"unknown";
                       if( backend != selected_backend )
                       { if( backend == "epkowa" )
                         { // In case of same support status, the epkowa driver is considered to be better
                           // than any other driver (in particular better than epson, plustek, or snapscan).
                           // Select the current model:
                           selected_model_database_index = database_index;
                           y2milestone( "Selected other model: %1", model_string );
                         }
                         else
                         { if( backend == "hpaio" )
                           { // In case of same support status, the hpaio driver is considered to be better
                             // than any other driver (in particular better than the outdated hpoj).
                             // Select the current model:
                             selected_model_database_index = database_index;
                             y2milestone( "Selected other model: %1", model_string );
                           }
                         }
                       }
                       else
                       { // The drivers are the same.
                         if( backend == "epkowa" )
                         { // Many models for the epkowa driver are available under two names.
                           // One name is the "overseas version" of the Japanese name.
                           // This is mentioned in the comment, e.g. the "Perfection 1200U PHOTO" has the comment
                           // "overseas version of the GT-7600UF, Perfection 1200U with TPU option bundled".
                           // Prefer the "overseas version" entry because most users are "overseas"
                           // (from the Japanese point of view) and even users in Japan find their model name
                           // in the comment (which is not true the other way round):
                           if( regexpmatch( tolower( comment ), tolower( "overseas version" ) ) )
                           { // Select the current model:
                             selected_model_database_index = database_index;
                             y2milestone( "Selected other model: %1", model_string );
                           }
                         }
                       }
                     }
                   }
                 }
               }
               // Take the filter_string into account:
               if( "" == filter_string )
               { model_items = add( model_items, `item( `id( database_index ), model_string ) );
               }
               else
               { // If the filter_string is not the empty string then
                 // test whether the model_string matches to the filter_string:
                 if( regexpmatch( tolower( model_string ), tolower( filter_string ) ) )
                 { model_items = add( model_items, `item( `id( database_index ), model_string ) );
                 }
               }
             }
           }
         );
  // Preselect the entry in the model_items list which matches
  // to the current value of selected_model_database_index
  // if such an entry exists in the model_items list (e.g. because of the
  // filter_string there may be no such entry in the model_items list):
  integer model_items_index = -1;
  integer selected_model_items_index = -1;
  term dummy = `id(0);
  // Determine if such an entry exists:
  foreach( term model_item,
           model_items,
           { // Set the model_items_index to the index number of the current model_item:
             model_items_index = model_items_index + 1;
             // model_item[0] is the term `id(database_index) and id[0] is the database_index
             // so that model_item[0,0] is the database_index:
             if( selected_model_database_index == model_item[0,0]:-1 )
             { selected_model_items_index = model_items_index;
             }
           }
         );
  if( selected_model_items_index >= 0 )
  { // Actually preselect the entry.
    // model_items[selected_model_items_index] is a model_item and
    // model_item[1] is the model_string and
    // model_item[0,0] is the database_index (see the previous comment) so that
    // model_items[selected_model_items_index,0,0] is the database_index:
    database_index = model_items[selected_model_items_index,0,0]:-1;
    model_string = model_items[selected_model_items_index,1]:"";
    model_items[selected_model_items_index] = `item( `id( database_index ), model_string, true );
    y2milestone( "Preselected model shown to the user: %1", model_string );
  }
  else
  { y2milestone( "No preselected model shown to the user. The filter_string is: '%1'", filter_string );
  }
  // Return a list which is sorted according to the model_string entries
  // (model_item[0] is `id(database_index) and model_item[1] is the model_string):
  return sort( term one_model_item,
               term another_model_item,
               model_items,
               { return one_model_item[1]:"" < another_model_item[1]:""; }
             );
}

/**
 * Activate the backend in /etc/sane.d/dll.conf
 * according to the specified backend_name
 * or if the specified backend_name is the empty string
 * then set the backend_name according to a specified database_index.
 * @param backend_name string of a backend which should be activated
 *        (if backend_name is the empty string then database_index must be >= 0)
 * @param database_index integer which points to an entry in the model database
 *        (if backend_name is the empty string then the backend according to the database_index is used)
 * @param user_confirmation boolean true if user confirmation popup in case of problems is requested
 * @return true on success
 */
global boolean ActivateBackend( string backend_name, integer database_index, boolean user_confirmation )
{ // First of all the multi-line strings because such strings cannot be indented:
  string firmware_message =
  // The body of a Popup::AnyMessage for scanners which require a firmware upload
  // Below this message on a seperated line a special command will be shown.
  // The "somewhere" is important because normally the firmware file is not simply
  // stored on the manufacturer's CD but often it is buried in a weird Windows-only
  // driver archive format. The text must indicate this.
  // Do not change or translate "SANE", it is a project name.
_("A firmware file contains software that must be uploaded to the scanner's memory.
Without firmware, the scanner cannot work.

Because firmware is licensed by the scanner manufacturer, we cannot distribute it.
Usually the firmware file is stored somewhere on the manufacturer's CD.
Alternatively, it may be possible to download it from the manufacturer's Web site.
Ask the manufacturer how to get the firmware file for your particular scanner.
Find additional useful information on the SANE Web site at
http://www.sane-project.org/.

After you get the firmware file, you must configure the driver manually.
The man page of the driver describes how to configure it for firmware upload.
The following command shows the man page for your driver:
");
  string hpaio_message =
  // Message of a Popup::YesNo for scanners which should be set up with the hpaio driver.
  // Do not change or translate "hpaio", it is a driver name.
  // Do not change or translate "hplip", it is a service name.
  // Do not change or translate "PTAL", it is a subsystem name.
_("The hpaio driver needs the hplip service to be up and running to show the device status.
Additionally, the hplip service should be configured to start when booting.
The hplip service and the PTAL system exclude each other.
Therefore a running PTAL system would be stopped and deactivated
before the the hplip service is activated and started.

Should the hplip service be activated and started now?
");
  string ptal_in_use_conflict_message =
  // Message of a Popup::ContinueCancel for scanners which should be set up with the hpaio driver.
  // Do not change or translate "ptal", it is a service name.
  // Do not change or translate "HPLIP", it is a subsystem name.
_("There is at least one printer configuration that uses the ptal service.
It is possible to proceed but then the ptal service would be stopped
and all print queues that use the ptal service would no longer work.
When you proceed, change the printer configuration to use HPLIP.
");
  string hpoj_message =
  // Message of a Popup::YesNo for scanners which should be set up with the hpoj driver
  // Do not change or translate "hpoj", it is a driver name.
  // Do not change or translate "PTAL", it is a subsystem name.
  // Do not change or translate "ptal", it is a service name.
  // Do not change or translate "hplip", it is a service name.
_("The hpoj driver requires the PTAL system to be set up and running.
In particular, the ptal service must be up and running.

Before the ptal service can be started, the PTAL system must be initialized.
Additionally, the ptal service should be activated for start when booting.
The PTAL system and the hplip service exclude each other.
Therefore a running hplip service would be stopped and deactivated
before the the PTAL system is initialized, activated, and started.
An automated initialization of the PTAL system is only safe for USB.
If you have a non-USB device or if the automated initialization for USB fails,
set up the PTAL system manually.
If you have an all-in-one device (scanner+printer), note that
a running ptal service monopolizes the USB device file (e.g., /dev/usb/lp0),
so the printer can no longer be addressed via the USB device file.

Should the PTAL system for USB be initialized, activated, and started now?
");
  string hplip_in_use_conflict_message =
  // Message of a Popup::ContinueCancel for scanners which should be set up with the hpoj driver.
  // Do not change or translate "hplip", it is a service name.
  // Do not change or translate "hpaio", it is a driver name.
  // Do not change or translate "ptal", it is a service name.
_("There is at least one printer configuration that uses the hplip service.
It is possible to proceed but then the hplip service would be stopped
and all print queues that use the hplip service would no longer work.
If the scanner is also supported by the hpaio driver, do not proceed.
Instead use hpaio to set up the scanner.
Alternatively proceed and change the printer configuration to use the ptal service.
");
  // Here the real code starts with proper indentation:
  if( backend_name == "" )
  { if( database_index < 0 )
    { y2milestone( "Error: Scanner database_index is: %1", database_index );
      return false;
    }
    backend_name = database[database_index,"backend"]:"unknown";
    if( "unknown" == backend_name )
    { y2milestone( "Error: Cannot activate backend: %1", backend_name );
      return false;
    }
  }
  // To be safe assume that something will really be modified.
  // If there is in fact nothing modified, it doesn't harm if 'modified' is 'true':
  modified = true;
  // Define the progress stages:
  Progress::New( // Header of a Progress::New:
                 // %1 will be replaced by the backend name
                 sformat( _("Setting Up Driver %1"),
                          backend_name
                        ),
                 " ",
                 6,
                 [ // 1. progress stage name of a Progress::New:
                   _("Check whether additional packages must be installed"),
                   // 2. progress stage name of a Progress::New:
                   _("Check whether firmware upload is required"),
                   // 3. progress stage name of a Progress::New:
                   _("Test and set up special requirements for particular drivers"),
                   // 4. progress stage name of a Progress::New:
                   _("Activate the driver"),
                   // 5. progress stage name of a Progress::New:
                   _("Determine active scanners"),
                   // 6. progress stage name of a Progress::New:
                   _("Test and set USB and SCSI scanner access permissions")
                 ],
                 [ // 1. progress step progress bar title of a Progress::New:
                   _("Checking whether additional packages must be installed..."),
                   // 2. progress step progress bar title of a Progress::New:
                   _("Checking whether firmware upload is required..."),
                   // 3. progress step progress bar title of a Progress::New:
                   _("Testing and setting up special requirements for particular drivers..."),
                   // 4. progress step progress bar title of a Progress::New:
                   _("Activating the driver..."),
                   // 5. progress step progress bar title of a Progress::New:
                   _("Determining active scanners..."),
                   // 6. progress step progress bar title of a Progress::New:
                   _("Testing and setting USB and SCSI scanner access permissions..."),
                   // Last progress step progress bar title of a Progress::New:
                   _("Finished")
                 ],
                 ""
               );
  // Test if the package which provides the backend is installed
  // and if not then try to install it.
  // This makes only sense if a database_index was specified
  // because which package is required for which backend is stored in the database
  // and additionally user confirmation must be requested.
  // Otherwise skip this section.
  Progress::NextStage();
  string package_name = database[database_index,"package"]:"unknown";
  if( package_name != "unknown"
      && user_confirmation
    )
  { if( ! TestAndInstallPackage( package_name ) )
    { Popup::AnyMessage( // Header of a Popup::AnyMessage:
                         _("Required Package Not Installed"),
                         // Body of a Popup::AnyMessage where
                         // %1 will be replaced by the backend name
                         // %2 will be replaced by the package name
                         // Only a simple message because before there was a dialog
                         // which let the user install the package so that this message is shown
                         // if the user has explicitely rejected to install it.
                         sformat( _("The driver %1 requires the package %2."), backend_name, package_name )
                       );
      Progress::Title( // Last progress step progress bar title when the Progress was aborted:
                       _("Aborted")
                     );
      return false;
    }
  }
  // Some scanners require a firmware upload to become ready to operate.
  // When building the sane package ':firmware "required"' entries have been
  // added for the respective scanners to the appropriate descriptions files.
  // See the sane.spec file of the sane package.
  // This makes only sense if a database_index was specified
  // because which scanner requires firmware upload is stored in the database
  // and additionally user confirmation must be requested.
  // Otherwise skip this section.
  Progress::NextStage();
  string firmware_entry = database[database_index,"firmware"]:"unknown";
  if( "required" == firmware_entry
      && user_confirmation
    )
  { Popup::AnyMessage( // Header of a Popup::AnyMessage for scanners which require a firmware upload:
                       _("Firmware Upload Required"),
                       firmware_message + "\n    man sane-" + backend_name
                     );
  }
  // Set up special requirements for particular backends (e.g. "hpaio", "hpoj"):
  Progress::NextStage();
  // The hpaio backend (from the package hplip) recommends the hplip service to be up and running.
  // Since HPLIP version 2.7.6 one part of the hplip service hpiod is replaced
  // by new direct device I/O (via hpmud library), only hpssd (for device status) still exists
  // but hpssd is not strictly required but without it hp-toolbox cannot show the device status
  // so that the hplip service (since HPLIP 2.7.6 only hpssd) is still recommended to run:
  // This makes only sense if user confirmation is requested.
  // Otherwise skip this section.
  if( "hpaio" == backend_name
      && user_confirmation
    )
  { if( ! Popup::YesNo( hpaio_message ) )
    { // The user has decided not to activate/start the hplip service:
      // Don't abort (i.e. return false) in this case because it is no error
      // when the user has decided not to activate/start the hplip service
      // because it may be already up and running or the user may want to set it up manually.
      // Regardless of the state of the hplip service the backend can be activated in /etc/sane.d/dll.conf
      Report::Warning(
                       // Message of a Report::Warning for scanners which should be set up with the hpaio backend.
                       // Only a simple message because before there was a Popup::YesNo
                       // which asked the user whether he wants to let YaST activate the hplip service
                       // so that this message is shown if the user has explicitely rejected to do it.
                       // Do not change or translate "hplip", it is a service name.
                       // Do not change or translate "hp-toolbox", it is a program name.
                       _("If the hplip service is not running, no device status can be shown in hp-toolbox.")
                     );
    }
    else
    { // The user has decided to activate/start the hplip service:
      // It may happen that the conflicting service ptal is in use by the printing system.
      // The ptal service is associated with the hpoj backend.
      if( DependantPrintQueueExists( "hpoj" ) )
      { // There is at least one conflicting print queue:
        if( ! Popup::ContinueCancel( ptal_in_use_conflict_message ) )
        { // The user doesn't want to proceed:
          y2milestone( "Set up hpaio SANE backend aborted by user because of conflict: PTAL is in use by a CUPS queue." );
          Progress::Title( // Last progress step progress bar title when the Progress was aborted:
                           _("Aborted")
                         );
          return false;
        }
      }
      // No conflicting print queue was found or
      // a conflicting print queue was found but the user forced to proceed:
      if( ! ExecuteBashCommand( setup_hplip_scanner_service_commandline ) )
      { Report::Error( sformat( // Message of a Report::Error where %1 can be replaced by an error message
                                // if such an error message exists.
                                // Only a simple message because this error does not happen on a normal system
                                // (i.e. a system which is not totally broken or totally messed up).
                                // Do not change or translate "hplip", it is a service name.
                                _("Failed to set up the hplip service.\n%1"),
                                OnlyMeaningfulErrorMessage( result["stderr"]:"" )
                              )
                     );
        Progress::Title( // Last progress step progress bar title when the Progress was aborted:
                         _("Aborted")
                       );
        return false;
      }
    }
  }
  // The hpoj backend (from the package hp-officeJet) requires the PTAL service to be up and running.
  // Before starting the PTAL service works it must have been initialized.
  // Automated initialization of the PTAL stuff is only safe for USB.
  // This makes only sense if user confirmation is requested.
  // Otherwise skip this section.
  if( "hpoj" == backend_name
      && user_confirmation
    )
  { if( ! Popup::YesNo( hpoj_message ) )
    { // The user has decided not to initialize/activate/start the PTAL system:
      // Don't abort (i.e. return false) in this case because it is no error
      // when the user has decided not to initialize/activate/start the PTAL system
      // because it may be already up and running or the user may want to set it up manually.
      // Regardless of the state of the PTAL system the backend can be activated in /etc/sane.d/dll.conf
      Report::Warning(
                       // Message of a Report::Warning for scanners which should be set up with the hpoj backend.
                       // Only a simple message because before there was a Popup::YesNo
                       // which asked the user whether he wants to let YaST activate the ptal service
                       // so that this message is shown if the user has explicitely rejected to do it.
                       // Do not change or translate "ptal", it is a service name.
                       _("If the ptal service is not running, the scanner cannot work.")
                     );
    }
    else
    { // The user has decided to initialize/activate/start the PTAL system:
      // It may happen that the conflicting service hplip is in use by the printing system.
      // The hplip service is associated with the hpaoi backend.
      if( DependantPrintQueueExists( "hpaio" ) )
      { // There is at least one conflicting print queue:
        if( ! Popup::ContinueCancel( hplip_in_use_conflict_message ) )
        { // The user doesn't want to proceed:
          y2milestone( "Set up hpoj SANE backend aborted by user because of conflict: HPLIP is in use by a CUPS queue." );
          Progress::Title( // Last progress step progress bar title when the Progress was aborted:
                           _("Aborted")
                         );
          return false;
        }
      }
      // No conflicting print queue was found or
      // a conflicting print queue was found but the user forced to proceed:
      if( ! ExecuteBashCommand( setup_ptal_scanner_service_commandline ) )
      { Report::Error( sformat( // Message of a Report::Error where %1 can be replaced by an error message
                                // if such an error message exists.
                                // Only a simple message because this error does not happen on a normal system
                                // (i.e. a system which is not totally broken or totally messed up).
                                // Do not change or translate "PTAL", it is a subsystem name.
                                _("Failed to set up the PTAL system.\n%1"),
                                OnlyMeaningfulErrorMessage( result["stderr"]:"" )
                              )
                     );
        Progress::Title( // Last progress step progress bar title when the Progress was aborted:
                         _("Aborted")
                       );
        return false;
      }
    }
  }
  // Activate the backend via bash script:
  Progress::NextStage();
  if( ! ExecuteBashCommand( activate_backend_commandline + " " + backend_name ) )
  { Progress::Title( // Last progress step progress bar title when the Progress was aborted:
                     _("Aborted")
                   );
    return false;
  }
  // Determine active scanners and active backends anew
  // and set USB and SCSI scanner access permissions anew.
  // Return successfully regardless of the result of this steps
  // because the backend was successfully activated.
  Progress::NextStage();
  if( ! DetermineActiveScanners() )
  { active_scanners = [];
    // This Progress::NextStage makes sure that
    // the stage "Test and set USB and SCSI scanner access permissions"
    // is shown to the user even if it is not actually executed.
    // But because of the word "Test" it is not wrong to show it.
    Progress::NextStage();
  }
  else
  { Progress::NextStage();
    if( ! SetScannerAccessPermissions()
        && user_confirmation
      )
    { Report::Warning( sformat( // Message of a Report::Warning when setting scanner access permissions failed
                                // where %1 can be replaced by an error message if such an error message exists.
                                // Only a simple message because this error does not happen on a normal system
                                // (i.e. a system which is not totally broken or totally messed up).
                                _("Failed to set scanner access permissions.\n%1"),
                                OnlyMeaningfulErrorMessage( result["stderr"]:"" )
                              )
                     );
    }
  }
  if( ! DetermineActiveBackends() )
  { active_backends = [];
  }
  Progress::Finish();
  return true;
}

/**
 * Deactivate the backend in /etc/sane.d/dll.conf
 * according to the specified backend_name
 * or if the specified backend_name is the empty string
 * then set the backend_name according to a specified database_index.
 * @param backend_name string of a backend which should be deactivated
 *        (if backend_name is the empty string then database_index must be >= 0)
 * @param database_index integer which points to an entry in the model database
 *        (if backend_name is the empty string then the backend according to the database_index is used)
 * @param user_confirmation boolean true if user confirmation popup in case of problems is requested
 * @return true on success
 */
global boolean DeactivateBackend( string backend_name, integer database_index, boolean user_confirmation )
{ if( backend_name == "" )
  { if( database_index < 0 )
    { y2milestone( "Error: Scanner database_index is: %1", database_index );
      return false;
    }
    backend_name = database[database_index,"backend"]:"unknown";
    if( "unknown" == backend_name )
    { y2milestone( "Error: Cannot deactivate backend: %1", backend_name );
      return false;
    }
  }
  // To be safe assume that something will really be modified.
  // If there is in fact nothing modified, it doesn't harm if 'modified' is 'true':
  modified = true;
  // Determine which of the active scanners will be deactivated.
  list< map< string, string > > scanners_to_deactivate = [];
  foreach( map< string, string > active_scanner,
           active_scanners,
           { if( active_scanner["backend"]:"unknown" == backend_name )
             { scanners_to_deactivate = add( scanners_to_deactivate, active_scanner );
             }
           }
         );
  // If more than one active scanners will be deactivated
  // then list the active scanners which will be deactivated
  //      and show them to the user
  //      and ask the user for confirmation:
  if( size( scanners_to_deactivate ) > 1 )
  { if( ! user_confirmation )
    { // Return true if more than one scanner would be deactivated
      // without asking the user for confirmation because it is the intended behaviour
      // not to deactivate more than one scanner without explicite user confirmation.
      // This happens for example when DeactivateBackend is called from dialogs.ycp
      // when the user goes back from ConfigureBackendDialog to SelectModelDialog.
      return true;
    }
    string entry = "";
    // Header message for a list of scanners which will be deactivated:
    string message = _("The following scanners use the same driver.\nTherefore all those scanners will be deactivated:");
    foreach( map< string, string > scanner_to_deactivate,
             scanners_to_deactivate,
             { entry = sformat( // Entries of a list of scanners which will be deactivated.
                                // %1 will be replaced by the manufacturer name
                                // %2 will be replaced by the model name
                                // %3 will be replaced by the device name where the scanner is connected to:
                                _("%1 %2 at %3"),
                                // Fallback manufacturer name if the real manufacturer name is missing:
                                scanner_to_deactivate["manufacturer"]:_("Unknown manufacturer"),
                                // Fallback model name if the real model name is missing:
                                scanner_to_deactivate["model"]:_("Unknown model"),
                                // Fallback device name if the real device name is missing:
                                scanner_to_deactivate["sane_device"]:_("Unknown device")
                              );
               message = message + "\n" + entry;
             }
           );
    if( ! Popup::ContinueCancel( message ) )
    { // Return true in this case because it is no error
      // when the user has decided not to deactivate the backend:
      return true;
    }
  }
  // Deactivate the backend via bash script:
  if( ! ExecuteBashCommand( deactivate_backend_commandline + " " + backend_name ) )
  { Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the driver name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("Failed to deactivate %1."), backend_name ) );
    return false;
  }
  // Unset the special requirements for particular backends (e.g. "hpaio", "hpoj")
  // if they are not needed otherwise (i.e. by the printing system):
  if( "hpaio" == backend_name )
  { // Stop and disable the hplip service if it is not needed by the printing system
    // (i.e. if there is no print queue which uses the hplip service).
    // The hplip service is associated with the hpaio backend.
    if( DependantPrintQueueExists( "hpaio" ) )
    { // There is at least one print queue which uses the hplip service:
      // Don't abort (i.e. return false) in this case because it is perfectly o.k.
      // but show a user notification why the hplip service must be still active.
      if( user_confirmation )
      { Popup::Notify ( // Message of a Popup::Notify after the hpaio driver was deactivated.
                        // Only a simple message because everything is perfectly o.k.
                        // but the user should get a notification
                        // why the hplip service must be still active.
                        // This works only if the CUPS printing system is used.
                        // Do not change or translate "hpaio", it is a driver name.
                        // Do not change or translate "hplip", it is a service name.
                        // Do not change or translate "CUPS", it is a subsystem name.
                        _("The driver hpaio is deactivated but the associated service hplip is not deactivated because it is needed by the CUPS printing system.")
                      );
      }
    }
    else
    { // There is no print queue which uses the hplip service:
      // Therefore the hplip service will be stopped and disabled if it exists.
      // Don't abort (i.e. return false) if this fails but show an error message to the user.
      if( Service::Status( "hplip" ) >= 0 )
      { // The hplip service exists:
        if( ! Service::Stop( "hplip" ) )
        { y2milestone( "Service::Stop('hplip') failed." );
          if( user_confirmation )
          { Report::Error( // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           // Do not change or translate "hplip", it is a service name.
                           _("Failed to stop the hplip service.")
                         );
          }
        }
        if( ! Service::Disable( "hplip" ) )
        { y2milestone( "Service::Disable('hplip') failed." );
          if( user_confirmation )
          { Report::Error( // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           // Do not change or translate "hplip", it is a service name.
                           _("Failed to disable the hplip service.")
                         );
          }
        }
      }
    }
  }
  if( "hpoj" == backend_name )
  { // Stop and disable the ptal service if it is not needed by the printing system
    // (i.e. if there is no print queue which uses the ptal service).
    // The ptal service is associated with the hpoj backend.
    if( DependantPrintQueueExists( "hpoj" ) )
    { // There is at least one print queue which uses the ptal service:
      // Don't abort (i.e. return false) in this case because it is perfectly o.k.
      // but show a user notification why the ptal service must be still active.
      if( user_confirmation )
      { Popup::Notify ( // Message of a Popup::Notify after the hpoj driver was deactivated.
                        // Only a simple message because everything is perfectly o.k.
                        // but the user should get a notification
                        // why the ptal service must be still active.
                        // This works only if the CUPS printing system is used.
                        // Do not change or translate "hpoj", it is a driver name.
                        // Do not change or translate "ptal", it is a service name.
                        // Do not change or translate "CUPS", it is a subsystem name.
                        _("The driver hpoj is deactivated but the associated service ptal is not deactivated because it is needed by the CUPS printing system.")
                      );
      }
    }
    else
    { // There is no print queue which uses the ptal service:
      // Therefore the ptal service will be stopped and disabled if it exists:
      // Don't abort (i.e. return false) if this fails but show an error message to the user.
      if( Service::Status( "ptal" ) >= 0 )
      { // The ptal service exists:
        if( ! Service::Stop( "ptal" ) )
        { y2milestone( "Service::Stop('ptal') failed." );
          if( user_confirmation )
          { Report::Error( // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           // Do not change or translate "ptal", it is a service name.
                           _("Failed to stop the ptal service.")
                         );
          }
        }
        if( ! Service::Disable( "ptal" ) )
        { y2milestone( "Service::Disable('ptal') failed." );
          if( user_confirmation )
          { Report::Error( // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           // Do not change or translate "ptal", it is a service name.
                           _("Failed to disable the ptal service.")
                         );
          }
        }
      }
    }
  }
  // Determine active scanners and active backends anew
  // and set USB and SCSI scanner access permissions anew.
  // Return successfully regardless of the result of this steps
  // because the backend was successfully deactivated.
  if( ! DetermineActiveScanners() )
  { active_scanners = [];
  }
  else
  { if( ! SetScannerAccessPermissions()
        && user_confirmation
      )
    { Report::Warning( sformat( // Message of a Report::Warning when setting scanner access permissions failed
                                // where %1 can be replaced by an error message if such an error message exists.
                                // Only a simple message because this error does not happen on a normal system
                                // (i.e. a system which is not totally broken or totally messed up).
                                _("Failed to set scanner access permissions.\n%1"),
                                OnlyMeaningfulErrorMessage( result["stderr"]:"" )
                              )
                     );
    }
  }
  if( ! DetermineActiveBackends() )
  { active_backends = [];
  }
  return true;
}

/**
 * Test the backend according to the specified backend_name.
 * @param backend_name string of a backend which should be tested
 * @return true on success
 */
global boolean TestBackend( string backend_name )
{ string sane_device = "";
  // It is not possible to test a backend without a matching active scanner.
  // Build the table of active scanners of the backend (see ModelItems above):
  list< term > scanners_to_be_tested = [];
  boolean preselect = true;
  foreach( map< string, string > active_scanner,
           active_scanners,
           { if( backend_name == active_scanner["backend"]:"unknown" )
             { sane_device = active_scanner["sane_device"]:"unknown";
               if( sane_device != "unknown" )
               { string model_string = active_scanner["manufacturer"]:"unknown"
                                       + " "
                                       + active_scanner["model"]:"unknown"
                                       + " at "
                                       + sane_device;
                 scanners_to_be_tested = add( scanners_to_be_tested,
                                              `item( `id( sane_device ), model_string , preselect ) );
                 // preselect must be true only for the first matching active scanner:
                 preselect = false;
               }
             }
           }
         );
  y2milestone( "scanners_to_be_tested: %1", scanners_to_be_tested );
  // If there is no active scanner for the backend
  // then show a message but exit successfully because
  // it is no error when there is no active scanner for the backend:
  if( size( scanners_to_be_tested ) < 1 )
  { Report::ShowText( sformat( // Header of a Report::ShowText where %1 will be replaced by the driver name:
                               _("No Scanner for %1"), backend_name ),
                               // Body of a Report::ShowText:
                               _("It is not possible to test without a matching active scanner.") );
    return true;
  }
  // If there is more than one active scanner for the backend
  // then ask the user which of the active scanners should be tested.
  // If there is exactly one active scanner for the backend
  // then don't ask because sane_device is already set to this one.
  if( size( scanners_to_be_tested ) > 1 )
  { UI::OpenDialog( `VBox( `HSpacing(60),
                           `SelectionBox( `id(`device_selection),
                                          // Header of a SelectionBox with a list of scanners:
                                          _("&Scanner to Test"),
                                          scanners_to_be_tested
                                        ),
                           `HBox( `PushButton( `id(`cancel_button), Label::CancelButton() ),
                                  `PushButton( `id(`ok_button), `opt(`default), Label::OKButton() )
                                )
                         )
                  );
    if( UI::UserInput() != `ok_button )
    { // Return true in this case because it is no error
      // when the user has decided not to do the test:
      UI::CloseDialog();
      return true;
    }
    sane_device = (string)UI::QueryWidget( `id(`device_selection), `CurrentItem );
    UI::CloseDialog();
  }
  // Test the device:
  y2milestone( "sane_device which will be tested: %1", sane_device );
  Popup::ShowFeedback( sformat( // Header of a Popup::ShowFeedback where %1 will be replaced by the driver name:
                                _("Testing %1"), backend_name ),
                                // Body of a Popup::ShowFeedback where %1 will be replaced by the SANE device identifier.
                                // Do not change or translate "scanimage -d %1 -v", it is a fixed command.
                       sformat( _("Testing with 'scanimage -d %1 -v'..."),
                                sane_device
                              )
                     );
  if( ! ExecuteBashCommand( test_backend_commandline + " " + sane_device ) )
  { Popup::ClearFeedback();
    Report::Error( sformat( // Message of a Report::Error where
                            // %1 will be replaced by the SANE device identifier
                            // %2 will be replaced by the actual test results
                            //    which are usually only available in English.
                            // Do not change or translate "scanimage -d %1 -v", it is a fixed command.
                            _("Test with 'scanimage -d %1 -v' failed.\nThe results are:\n\n%2"),
                            sane_device,
                            // Fallback message if the real results are missing:
                            result["stderr"]:_("(no results available)")
                          )
                 );
    // If the test failed, do the whole autodetection anew.
    // Even if normally nothing should have changed because of a failed test,
    // it might have happened that for example during the test somehow
    // the scanner had fallen into coma or the USB or SCSI system had crashed
    // and then the scanner would be no longer an active scanner nor could it be autodetected.
    // To simulate such an event, simply unplug an USB scanner while it is being tested.
    RestartDetection();
    return false;
  }
  Popup::ClearFeedback();
  Report::ShowText( sformat( // Header of a Report::ShowText where %1 will be replaced by the driver name:
                             _("Successfully Tested %1"), backend_name
                           ),
                    sformat( // Body of a Report::ShowText where
                             // %1 will be replaced by the SANE device identifier
                             // %2 will be replaced by the actual test results
                             //    which are usually only available in English.
                             // Do not change or translate "scanimage -d %1 -v", it is a fixed command.
                             _("Test with 'scanimage -d %1 -v' succeeded.\nThe results are:\n\n%2"),
                             sane_device,
                             // Fallback message if the real results are missing:
                             result["stderr"]:_("(no results available)")
                           )
                  );
  return true;
}

/**
 * Determine the network scanning config by calling a bash script
 * which calls "grep ... /etc/sane.d/net.conf" and "grep ... /etc/sane.d/saned.conf"
 * and processes its output and stores the results as YCP map in a temporary file
 * and then read the temporary file (SCR::Read) to get the YCP map.
 * Additionally call SuSEFirewall functions to determine the firewall settings
 * regarding remote access to the saned (service "sane-port" 6566/tcp,6566/udp).
 * @return true on success
 */
global boolean DetermineNetworkScanningConfig()
{ if( ! ExecuteBashCommand( determine_network_scanning_config_commandline ) )
  { Report::Error( // Message of a Report::Error.
                   // Only a simple message because this error does not happen on a normal system
                   // (i.e. a system which is not totally broken or totally messed up).
                   // Do not confuse this error with the case when no scanning via network was configured.
                   // The latter results no error.
                   _("Failed to determine the configuration for scanning via network.")
                 );
    return false;
  }
  if( -1 == SCR::Read( .target.size, network_scanning_config_filename ) )
  { y2milestone( "Error: %1: file does not exist.", network_scanning_config_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("File %1 does not exist."),
                            network_scanning_config_filename
                          )
                 );
    return false;
  }
  network_scanning_config = (map< string, string >)SCR::Read( .target.ycp, network_scanning_config_filename );
  if( nil == network_scanning_config )
  { y2milestone( "Error: Failed to read %1", network_scanning_config_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("Failed to read %1."),
                            network_scanning_config_filename
                          )
                 );
    network_scanning_config = $[];
    return false;
  }
  y2milestone( "Network scanning config: %1", network_scanning_config );
  // Determine the firewall settings regarding remote access to the saned:
  // Return successfully regardless of the result of this steps
  // because the mandatory network scanning config was successfully determined.
  // SuSEFirewall::Read shows a Progress.
  // Save previous Progress state and disable showing Progress:
  boolean progress_previous_state = Progress::set( false );
  if( ! SuSEFirewall::Read() )
  { // If firewall_config is the empty map, the user
    // cannot change a firewall setting and in SetupNetworkScanningConfig()
    // noting will be committed.
    y2milestone( "SuSEFirewall::Read failed." );
    firewall_config = $[];
    // Restore previous Progress state:
    Progress::set( progress_previous_state );
    return true;
  }
  // Restore previous Progress state:
  Progress::set( progress_previous_state );
  // Preset the firewall_config map with the
  // defaults after a default system installation
  // to have a reasonable fallback if the actual values regarding
  // firewall access permissions for the saned cannot be determined:
  firewall_config = $[ "suse_firewall_used":true,
                       "firewall_active":true,
                       "no_firewall_for_int":true,
                       "ui_no_firewall_for_int":true,
                       "denied_from_ext":true,
                       "ui_deny_from_ext":true
                     ];
  // Determine whether the Suse Firewall is used:
  if( SuSEFirewall::IsOtherFirewallRunning() )
  { // If not the Suse Firewall is used, the dialogs will not show
    // any firewall settings and therefore the user cannot change them.
    firewall_config["suse_firewall_used"] = false;
    y2milestone( "Not the Suse Firewall is used, i.e. another firewall is running." );
    return true;
  }
  // Determine whether the Suse Firewall is active:
  if( ! SuSEFirewall::IsStarted()
      || ! SuSEFirewall::GetStartService()
    )
  { // If the Suse Firewall is not active, the dialogs will not show
    // any firewall settings because it is useless and confusing
    // to let the user change firewall settings regarding saned
    // when the user had decided to have no firewall currently running
    // or if the firewall would not be started in SuSEFirewall::Write()
    firewall_config["firewall_active"] = false;
    y2milestone( "The Suse Firewall is not active or would not be started in SuSEFirewall::Write." );
    return true;
  }
  // Determine the actual settings regarding firewall access permissions for saned
  // and preset the user interface settings with the actual settings:
  if( SuSEFirewall::GetProtectFromInternalZone() )
  { firewall_config["no_firewall_for_int"] = false;
    firewall_config["ui_no_firewall_for_int"] = false;
  }
  else
  { firewall_config["no_firewall_for_int"] = true;
    firewall_config["ui_no_firewall_for_int"] = true;
  }
  if( SuSEFirewall::HaveService( "sane-port", "TCP", "EXT" )
      || SuSEFirewall::HaveService( "sane-port", "UDP", "EXT" )
    )
  { firewall_config["denied_from_ext"] = false;
    firewall_config["ui_deny_from_ext"] = false;
  }
  else
  { firewall_config["denied_from_ext"] = true;
    firewall_config["ui_deny_from_ext"] = true;
  }
  y2milestone( "Firewall network scanning config: %1", firewall_config );
  return true;
}

/**
 * Setup the network scanning config by calling a bash script which
 * activates or deactivates the "net" backend and which writes into
 * /etc/sane.d/net.conf, /etc/sane.d/saned.conf, and /etc/xinetd.d/sane-port
 * and reloads or starts the xinetd dependig on whether it is running or not.
 * Additionally call SuSEFirewall functions to commit changed firewall settings
 * regarding remote access to the saned (service "sane-port" 6566/tcp,6566/udp).
 * @return true on success
 */
global boolean SetupNetworkScanningConfig()
{ // To be safe assume that something will really be modified.
  // If there is in fact nothing modified, it doesn't harm if 'modified' is 'true':
  modified = true;
  // Build the commandline and then call it:
  string commandline = setup_network_scanning_config_commandline
                       + " '"
                       + network_scanning_config["net_backend_hosts"]:""
                       + "' '"
                       + network_scanning_config["saned_hosts"]:""
                       + "'";
  if( ! ExecuteBashCommand( commandline ) )
  { Report::Error( // Message of a Report::Error.
                   // Only a simple message because this error does not happen on a normal system
                   // (i.e. a system which is not totally broken or totally messed up).
                   // Do not confuse this error with the case when no scanning via network is to be set up.
                   // The latter results no error.
                   _("Failed to set up scanning via network.")
                 );
    return false;
  }
  // If the Suse Firewall is used and
  // if the Suse Firewall is active and
  // if firewall settings have been changed by the user,
  // then set and commit the new firewall settings.
  // Use safe fallback values  - i.e. in case of doubt don't do anything:
  if( firewall_config["suse_firewall_used"]:false
      && firewall_config["firewall_active"]:false
      && ( firewall_config["ui_no_firewall_for_int"]:true != firewall_config["no_firewall_for_int"]:true
           || firewall_config["ui_deny_from_ext"]:true != firewall_config["denied_from_ext"]:true
         )
    )
  { // Set new firewall settings in SuSEFirewall:
    y2milestone( "Set and commit new firewall network scanning config: %1", firewall_config );
    // Set new firewall settings regarding access allow from INT zone:
    if( ! firewall_config["no_firewall_for_int"]:true
        && firewall_config["ui_no_firewall_for_int"]:false )
    { // Firewall protects internal zone
      // but user has set no protection for internal zone.
      // The SuSEFirewall::SetProtectFromInternalZone returns void,
      // therefore there is no test possible whether it had worked.
      SuSEFirewall::SetProtectFromInternalZone(false);
      y2milestone( "SuSEFirewall::SetProtectFromInternalZone(false)" );
    }
    // Set new firewall settings regarding saned access deny from EXT zone:
    if( ! firewall_config["denied_from_ext"]:true
        && firewall_config["ui_deny_from_ext"]:false )
    { // Firewall allows saned access from the external zone
      // but user has set in dialog to deny saned access from the external zone:
      if( ! SuSEFirewall::RemoveService( "sane-port", "TCP", "EXT" )
          || ! SuSEFirewall::RemoveService( "sane-port", "UDP", "EXT" )
        )
      { y2milestone( "Error: SuSEFirewall::AddService(sane-port,TCP+UDP,EXT) failed." );
        Report::Error( // Message of a Report::Error.
                       // Only a simple message because this error does not happen on a normal system
                       // (i.e. a system which is not totally broken or totally messed up).
                       // Do not confuse this error with the case when no firewall stuff is to be set up.
                       // The latter results no error.
                       _("Failed to deny saned access from external zone in firewall.")
                     );
        return false;
      }
      y2milestone( "Success: SuSEFirewall::RemoveService(sane-port,TCP+UDP,EXT)" );
    }
    // Commit the new firewall settings:
    // SuSEFirewall::Write shows a Progress.
    // Save previous Progress state and disable showing Progress:
    boolean progress_previous_state = Progress::set( false );
    if( ! SuSEFirewall::Write() )
    { y2milestone( "Error: SuSEFirewall::Write failed to commit firewall settings regarding scanning via network." );
      Report::Error( // Message of a Report::Error.
                     // Only a simple message because this error does not happen on a normal system
                     // (i.e. a system which is not totally broken or totally messed up).
                     // Do not confuse this error with the case when no firewall stuff is to be set up.
                     // The latter results no error.
                     _("Failed to write firewall settings regarding scanning via network.")
                   );
      // Restore previous Progress state:
      Progress::set( progress_previous_state );
      return false;
    }
    // Restore previous Progress state:
    Progress::set( progress_previous_state );
  }
  // Determine active scanners and active backends anew.
  // Return successfully regardless of the result of this steps
  // because scanning via network was successfully set up.
  if( ! DetermineActiveScanners() )
  { active_scanners = [];
  }
  if( ! DetermineActiveBackends() )
  { active_backends = [];
  }
  return true;
}

/*
 * Autoinstallation stuff:
 *
 */

/**
 * Get all scanner settings from the first parameter.
 * For use by autoinstallation.
 * @param settings The YCP structure to be imported.
 * @return true on success
 */
global boolean Import( map settings )
{ return true;
}

/**
 * Dump the scanner settings to a single map.
 * For use by autoinstallation.
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export( )
{ return $[];
}

/**
 * Return packages needed to be installed and removed during
 * autoinstallation to insure module has all needed software installed.
 * @return map with 2 lists.
 */
global map AutoPackages()
{ return $[ "install":[], "remove":[] ];
}

/* EOF */

}

