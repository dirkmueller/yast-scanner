/**
 * File:	modules/Scanner.ycp
 * Package:	Configuration of scanner
 * Summary:	Scanner settings, input and output functions
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of scanner.
 * Input and output routines.
 */

{

module "Scanner";
textdomain "scanner";

import "Progress";
import "Report";
import "String";
import "Summary";
import "Popup";


global map user_settings = $[];

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;


// includes - may use variables

include "scanner/scanner_functions.ycp";


/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

// Settings: Define all variables needed for configuration of scanner
// TODO FIXME: Define all the variables necessary to hold
// TODO FIXME: the configuration here (with the appropriate
// TODO FIXME: description)
// TODO FIXME: For example:
//   /**
//    * List of the configured cards.
//    */
//   list cards = [];
//
//   /**
//    * Some additional parameter needed for the configuration.
//    */
//   boolean additional_parameter = true;

/**
 * Read all scanner settings
 * 0. is package "sane" installed?
 *    if NOT -> call sw_single
 * 1. Hardware probing
 *     SCR(.probe.scanner) 	-> hwinfo --scanner
 * 2. Check already installed scanner (perl script)
 * 3. Decide whether the detected scanner(s) is (are) installed/supported by SANE
 * 4. Decide which dialog is called next
 *
 * Shows the progress of hardware probing and scanner checking.
  * @return true on success
 */
global boolean Read() {

      symbol ret = `next;

      boolean test_mode = lookup( Scanner::user_settings, "test_mode", false );
    y2milestone ("Reading: Test mode: %1", test_mode);

      // Help text for start dialog (checking and probing)
      string help_text = _("<p>YaST2 is doing some checks, such as the
hardware probing of 'USB' or 'SCSI' ports.
</p>
");

      Progress::New(
		    // Headline for start dialog of scanner configuration
		    _("Initializing scanner module ..."),
		    "",	// progress_title
		    3,	// length
		    [
		     // 3 steps of probing soft- and hardware
		     // Translators: Please do not translate 'SANE'!
		     _("Checking whether SANE library is installed..."),
		     _("Probing hardware - looking for connected scanners..."),
		     _("Checking already installed scanners...")
		    ],
		    [],		// descriptions
		    help_text );

      Progress::NextStage( );
      // text for a progress bar label (please do not translate 'SANE')
      Progress::Title( _("Checking SANE library...") );

      if ( !test_mode )
      {
	  integer sane_installed = (integer) SCR::Execute (.target.bash, "/bin/rpm -q sane");
	  // check whether 'sane' is installed
	  y2debug( "SANE is installed: %1", sane_installed );
	  list packs_to_install = [];
	  string mesg = "";
	  boolean cont = true;
	  
	  if ( sane_installed != 0 )
	  {
	      // Popup text: ask the user 'Install package sane?' 
	      // Translators: 'SANE' is a library - don't translate!
	      mesg = _("For scanner access under Linux, the SANE library is required.
The package 'sane' has to be installed before proceeding with
the scanner configuration.

Install the package now?
");
	      packs_to_install = ["sane" ];

	      cont = Popup::YesNo(mesg);

	      if ( cont )
	      {
		  WFM::CallFunction ("sw_single", [packs_to_install]);
	      }
	  }

	  if ( SCR::Execute (.target.bash, "/bin/rpm -q sane") != 0 )
	  {
	      // SANE should be installed by now - if not inform the user and exit
	      Popup::Error(_("The package 'sane' is not installed correctly.
This package is mandatory for the scanner installation.
Make sure you have the SUSE CD set available
and restart the scanner installation. Alternatively, install the package
with the YaST2 module 'Install and Remove Software'.
"));
	      return false;
	  }
	  else
	  {
	      integer kooka_installed = (integer) SCR::Execute (.target.bash, "/bin/rpm -q kdegraphics3-scan");

	      if ( kooka_installed != 0 )
	      {
		  // Popup text: ask the user whether to install the scan program Kooka  
		  mesg = _("The program Kooka provides a user-friendly interface for scanning
(package 'kde3graphics-scan'). The package can be installed right now
or later with the YaST2 module 'Install and Remove Software'.

Install the package now?
");
		  packs_to_install = [ "kdegraphics3-scan" ];

		  cont = Popup::YesNo(mesg);

		  if ( cont )
		  {
		      WFM::CallFunction ("sw_single", [packs_to_install]);
		  }
	      }	      
	  	      
	  }
      }

      Progress::NextStage();
      // text for a progress bar label
      Progress::Title( _("Probing hardware") );

      integer usb_count = 0;
      list<map> connected_scanner = [];

      if ( !test_mode )
      {
	  // probe USB and SCSI ports; command is hwinfo --scanner
	  connected_scanner = (list<map>) SCR::Read(.probe.scanner);
	  list scanner_list = [];

	  foreach (map scanner, connected_scanner, ``{
	      if ( lookup( scanner, "bus", "" ) == "USB" )
	      {
		  // sub_class_id 1 means a HP all-in-one device
		  if ( lookup( scanner, "sub_class_id", 0) == 1 )
		  {
		      boolean installed = CheckOfficeJet();
		      if ( installed )
		      {
			   // call ptal-init setup
			  integer exitcode = (integer) SCR::Execute (.target.bash, "ptal-init setup-usb 2>&1 > /dev/null" );
			  // replace scanner entry
			  list<map> ptal_devices = (list<map>) SCR::Read(.scanner.ptal);
			  foreach (map device, ptal_devices, ``{
			      if ( lookup( device, "device", "") == lookup( scanner, "device", "" )
				   || lookup( device, "device", "") == lookup( scanner, "sub_device", "" ) )
			      {
				  if ( lookup( device, "scanner_driver", "" ) != "" )
				  {
				      device = add( device, "scanner_status", "supported" );
				  }
				  y2milestone ("PTAL device found: %1", device );
				  scanner_list = add(scanner_list, device);
			      }
			  });
		      }
		  }
		  else
		  {
		      usb_count = usb_count + 1;
		      scanner_list = add(scanner_list, scanner);
		  }
	      }
	      else
	      {
		  scanner_list = add(scanner_list, scanner);
	      }
	  });
	  connected_scanner = (list<map>)scanner_list;

	  if ( usb_count > 1 )
	  {
	      // only one USB scanner is supported by scanner library SANE
	      // and there are problems with hot plugin (changing device numbers)
	      // -> only *one* USB scanner is allowed

	      // text of an error popup "only one USB scanner allowed"
	      Popup::Error(_("YaST2 has detected several USB scanners connected to
your computer. At the moment only one USB scanner can
be configured, so please decide which one you want.\n
Disconnect all unwanted USB scanners and restart
the scanner configuration\n."));
	      return false;
	  }

	  y2milestone( "Connected Scanner: %1", connected_scanner);

          // add net scanner/call SCR::Read(.scanner.net) -> see below
      }
      else
      {
	  connected_scanner = lookup( Scanner::user_settings, "test_connected", [] );
      }

      Progress::NextStage( );
      // text for a progress bar label
      Progress::Title(_("Checking already installed scanners"));

      list<map> installed_scanner = [];
      if ( !test_mode )
      {
	  installed_scanner = (list<map>) SCR::Read(.scanner.configured);
	  y2debug("Configured scanner: %1", installed_scanner );
      }
      else
      {
	  installed_scanner = lookup( Scanner::user_settings, "test_installed", [] );
      }

      Progress::NextStep();
      // text for a progress bar label
      Progress::Title( _("Finishing the check procedure") );

      // find out which scanner is already installed / which is new / which is supported
      map scanner_info = $[];

      integer no = 1;

      foreach(map scanner, connected_scanner, ``{
	  string driver = "";
	  boolean found = false;
	  integer m = 0;
	  map scan = $[];

	  if ( !test_mode )
	  {
	      // try to get SANE scanner driver
	      driver = (string) SCR::Read(.sane.driver, scanner);
	  }
	  else
	  {
	      // get test data
 	      driver = lookup( scanner, "scanner_driver", "" );
	  }
	  //determine whether scanner is already installed
	  while ( !found && m < size(installed_scanner) )
	  {
	      scan = select( installed_scanner, m, $[] );
	      if ( ( tolower(lookup( scan, "vendor", "")) 	== tolower(lookup( scanner, "vendor", "")) ) 	&&
		   ( ( tolower(lookup( scan, "device", "")) 	== tolower(lookup( scanner, "device", "")) ) ||
		     ( tolower(String::CutBlanks(lookup( scan, "sub_device", ""))) == tolower(String::CutBlanks(lookup( scanner, "sub_device", ""))) ) )  &&
		   ( tolower(lookup( scan, "bus", "")) 		== tolower(lookup( scanner, "bus", "")) ) 	&&
		   ( tolower(lookup( scan, "dev_name", "")) 	== tolower(lookup( scanner, "dev_name", "")) ) )
	      {
		  scanner = add( scanner, "scanner_status", "installed" );
		  if(driver != "")
		  {
		    scanner = add( scanner, "scanner_driver", driver );
		  }
		  found = true;
	      }
	      m = m+1;
	  }

	  // scanner is not installed
	  if (!found )
	  {
	      // scanner is supported if driver is available
	      if ( driver != "" )
	      {
		  scanner = add( scanner, "scanner_status", "supported" );
		  scanner = add( scanner, "scanner_driver", driver );
	      }
	      else if ( lookup( scanner, "scanner_status", "" ) == "" )
	      {
		  // only set  status if not yet set (PTAL devices already have status "supported")
		  scanner = add( scanner, "scanner_status", "detected" );
	      }

	  }
	  // if the "device" or "vendor" entry is missing add the entry (set value of sub_....)
	  if ( lookup( scanner, "device", "") == "" )
	  {
	      scanner = add(scanner, "device", String::CutBlanks(lookup( scanner, "sub_device", "")) );
	  }
	  if ( lookup( scanner, "vendor", "") == "" )
	  {
	      scanner = add(scanner, "vendor", String::CutBlanks(lookup( scanner, "sub_vendor", "")) );
	  }
	  scanner_info = add(scanner_info, no, scanner);

	  no = no+1;
      });

      // Net scanner handling
      // The problem is, that one netstation can offer more than one scanner, but we
      // can only handle stations, but not entire scanner on stations. But that's the
      // way the SCR(Read(.scanner.net)) offers the net scanner list.
      // Thus we have to sort out and count scanners per station.

      // Get all scanners on the stations
      list<map> net_scanner = [];
    if (! test_mode)
	net_scanner = (list<map>) SCR::Read(.scanner.net);
      list<map> net_stations = [];
      foreach(map one_scanner, net_scanner, ``{

	  // search for the host.
	  string host = lookup( one_scanner, "host", "" );
	  if ( host != "" )
	  {
	      // start not believing that the one is already in the known stations list.
	      boolean found = false;
	      foreach(map station, net_stations, ``{
		  string station_name = lookup( station, "host", "notfound" );

		  // Check if the host is already known
		  if( station_name == host )
		  {
		      // ok, the host is already known, just add the device.
		      found = true;
		  }
	      });

	      string dev = lookup( one_scanner, "device", "" );
	      string vend = lookup( one_scanner, "vendor", "" );
	      if( found == true )
	      {
		  list<map> dummy = [];
		  foreach(map station, net_stations, ``{
		      string station_name = lookup( station, "host", "notfound" );
		      if( station_name == host )
		      {
			  // ok, the host is already known, just add the device.
			  station = add( station, "count", lookup( station, "count", 0 ) +1 );
			  station = add( station, "device", lookup( station, "device", "" ) + ", " + dev );
			  station = add( station, "vendor", lookup( station, "vendor", "" ) + ", " + vend );
		      }
		      dummy = add( dummy, station );
		  });
		  net_stations = dummy;
	      }
	      else
	      {
		  net_stations = add( net_stations, $[ "host":host, "device":dev, "count":1,
						     "scanner_status":"installed", "bus":"Net",
						     "vendor":vend ] );
	      }

	  }
	  else
	  {
	      y2debug( "ERROR: Host is not defined!" );
	  }

      });

      // finishing: put the net stations to the scanner_info - list
      // no is still defined from above.
      y2milestone( "Net Scanner: %1", net_scanner );
      y2debug("Net Stations found: %1", net_stations );

      foreach( map net_station, net_stations, ``{
	  y2debug("Adding net_station to scanner_info-list as no %1", no );
	  scanner_info = add(scanner_info, no, net_station);

	  no = no+1;
      });

      // write scanner data to Scanner::user_settings
      Scanner::user_settings = add( Scanner::user_settings, "scannerInfo", scanner_info );
      y2debug( "Writing SCANNER INFO: %1", scanner_info );

    return true;
}

/**
 * Write all scanner settings
 * @return true on success
 */
global boolean Write() {
      boolean ret = true;

      map<any,map> scanner_info = Scanner::user_settings["scannerInfo"]:$[];

      foreach( any key, map scanner, scanner_info, ``{

	  string usb_usermap = lookup( scanner, "usb_usermap", "" );
	  string bus = lookup( scanner, "bus", "" );
	  string scanner_driver = lookup( scanner, "scanner_driver", "" );
	  string is_installed = lookup( scanner, "scanner_status", "" );
	  string unique_key =  lookup( scanner, "unique_key", "" );

	  if( is_installed == "installed" )
	  {
	      boolean success = false;

	      SCR::Write(.probe.status.configured, unique_key, `yes);
	      y2milestone ( "Mark scanner %1 as configured",  unique_key );

	      if ( bus == "USB"
		   && usb_usermap != ""
		   && scanner_driver != "" )
	      {
		  // kernel 2.6: writing modules.conf is obsolete (scanner module is gone)

		  integer exitcode = 0;

		  // append USB IDs to /etc/sane.d/<driver>.conf
		  exitcode = (integer)SCR::Execute(.target.bash, sformat("echo \"usb %1\" >> /etc/sane.d/%2.conf",
							       usb_usermap, scanner_driver) );

		  if ( exitcode == 0 )
		  {
	      		  string user_entry = sformat ("desktopdev  0x0003  %1  0x0000       0x0000       0x00         0x00            0x00            0x00            0x00            0x00            0x00000000", usb_usermap );
		      // Write /etc/hotplug/usb/sane.usermap (using pseudo module name "desktopdev")
		      exitcode = (integer)SCR::Execute(.target.bash, sformat("echo \"%1\" >> /etc/hotplug/usb/sane.usermap", user_entry ) );
		  }
		  if ( exitcode != 0 )
		  {
		      y2error( "ERROR: Manual USB configuration failed" );
		      ret = false;
		  }
		  else
		  {
		      y2milestone( "Writing /etc/sane.d/%1.conf and /etc/hotplug/usb/sane.usermap" );
		  }
	      }
	      else if ( bus == "SCSI" )
	      {
		  // set the link in /etc/init.d/rc3.d to start the script /usr/sbin/rcsane
		  // (which sets and resets the permissions 666 on /dev/sg0 )
		  success = Service::Enable("sane");
		  y2milestone( "ServiceAdjust( sane, enable ) returns: %1", success );
		  if ( !success )
		      ret = false;
	      }
	      else if ( bus == "PTAL" )
	      {
		  // enable PTAL service and hotplug
		  success = Service::Enable("hotplug");
		  if ( success )
		  {
		      success = Service::Enable("ptal");
		  }
		  if ( !success )
		      ret = false;

		  y2milestone ( "PTAL service %1", success?"enabled":"NOT enabled" );
	      }
	  }
      });

      return ret;

}

/**
 * Get all scanner settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the scanner settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration summary ..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}

/* EOF */
}

